<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title>Carson的博客</title>
  <generator uri="https://github.com/jekyll/jekyll">Jekyll v2.4.0</generator>
    <icon>/apple-touch-icon-precomposed.png</icon>
  <subtitle>My Life</subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="/" rel="alternate" type="text/html"/>
  <updated>2015-07-12T14:13:46+08:00</updated>
  <id>/</id>
  <author>
    <name>Carson Lin</name>
    <uri>/</uri>
    <email>carsonxiaoyang@gmail.com</email>
  </author>

  
  <entry>
    <title>设计模式学习二</title>
    <link href="/study/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%BA%8C/"/>
    <updated>2015-06-08T00:00:00+08:00</updated>
    <id>/study/设计模式学习二</id>
    <author>
      <name>Carson Lin</name>
      <uri>/</uri>
      <email>carsonxiaoyang@gmail.com</email>
    </author>
    <content type="html">
      
      &lt;h3 id=&quot;section&quot;&gt;开头&lt;/h3&gt;
&lt;p&gt;    这一章我来总结下对5种创建型设计模式的学习。5种分别是&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;抽象工厂(Abstract Factory)&lt;/li&gt;
  &lt;li&gt;工厂方法(Factory Method)&lt;/li&gt;
  &lt;li&gt;单例模式(Singleton)&lt;/li&gt;
  &lt;li&gt;原型(Prototype)&lt;/li&gt;
  &lt;li&gt;生成器(Builder)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;例子一&lt;/h3&gt;
&lt;p&gt;    定义和概念太难看懂，我们从几个个例子和代码来总结和比较这几种设计模式。&lt;br /&gt;
    我们要组装一台只有CPU和显卡的PC。Intel、IBM都生产CPU、显卡。下面的例子将说明：
-	抽象工厂
-	工厂方法
-	单例模式&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; //PC
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt; class PC {
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt; 	virtual void addCPU(CPU*) {}//装配CPU
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt; 	virtual void addCard(Card*) {}//装配显卡
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt; //CPU类
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt; class CPU {}
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt; //显卡类
&lt;span class=&quot;lineno&quot;&gt;11&lt;/span&gt; class Card{}
&lt;span class=&quot;lineno&quot;&gt;12&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;13&lt;/span&gt; //Intel工艺的CPU
&lt;span class=&quot;lineno&quot;&gt;14&lt;/span&gt; class IntelCPU : public CPU {
&lt;span class=&quot;lineno&quot;&gt;15&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;16&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;17&lt;/span&gt; //IBM工艺的CPU
&lt;span class=&quot;lineno&quot;&gt;18&lt;/span&gt; class IBMCPU : public CPU {
&lt;span class=&quot;lineno&quot;&gt;19&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;20&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;21&lt;/span&gt; //Intel工艺的显卡
&lt;span class=&quot;lineno&quot;&gt;22&lt;/span&gt; class IntelCard : public Card {
&lt;span class=&quot;lineno&quot;&gt;23&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;24&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;25&lt;/span&gt; //IBM工艺的显卡
&lt;span class=&quot;lineno&quot;&gt;26&lt;/span&gt; class IBMCard : public Card {
&lt;span class=&quot;lineno&quot;&gt;27&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;28&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;29&lt;/span&gt; //抽象工厂
&lt;span class=&quot;lineno&quot;&gt;30&lt;/span&gt; class abstract_factory {
&lt;span class=&quot;lineno&quot;&gt;31&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt;32&lt;/span&gt; 	virtual PC* makePC() {}//工厂方法,返回一台PC
&lt;span class=&quot;lineno&quot;&gt;33&lt;/span&gt; 	virtual CPU* createCPU() {}//工厂方法,生产一个CPU
&lt;span class=&quot;lineno&quot;&gt;34&lt;/span&gt; 	virtual graphics_card* createCard() {}//工厂方法,生产一个显卡
&lt;span class=&quot;lineno&quot;&gt;35&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt;36&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;37&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;38&lt;/span&gt; //Intel工厂,不使用单例模式
&lt;span class=&quot;lineno&quot;&gt;39&lt;/span&gt; class Intel : public abstract_factory {
&lt;span class=&quot;lineno&quot;&gt;40&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt;41&lt;/span&gt; 	virtual CPU* createCPU() { return (CPU*) new IntelCPU }//override,生产一个IntelCPU
&lt;span class=&quot;lineno&quot;&gt;42&lt;/span&gt; 	virtual graphics_card* createCard() { return (graphics_card*) new IntelCard}//override,生产一个Intel显卡
&lt;span class=&quot;lineno&quot;&gt;43&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt;44&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;45&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;46&lt;/span&gt; //IBM工厂,使用单例模式
&lt;span class=&quot;lineno&quot;&gt;47&lt;/span&gt; class IBM : public abstract_factory {
&lt;span class=&quot;lineno&quot;&gt;48&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;49&lt;/span&gt; private:
&lt;span class=&quot;lineno&quot;&gt;50&lt;/span&gt; 	static IBM* _instance = 0;//指向实例化对象的指针
&lt;span class=&quot;lineno&quot;&gt;51&lt;/span&gt; protected:
&lt;span class=&quot;lineno&quot;&gt;52&lt;/span&gt; 	IBM(){}//将构造函数设置成protected方法,不能设成private，不然子类就实例化不了了
&lt;span class=&quot;lineno&quot;&gt;53&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt;54&lt;/span&gt; public:
&lt;span class=&quot;lineno&quot;&gt;55&lt;/span&gt; 	//返回一个IBM工厂实例
&lt;span class=&quot;lineno&quot;&gt;56&lt;/span&gt; 	static IBM* getInstance() {
&lt;span class=&quot;lineno&quot;&gt;57&lt;/span&gt; 	  if (0 == _instance) {
&lt;span class=&quot;lineno&quot;&gt;58&lt;/span&gt; 		  _instance = new IBM;
&lt;span class=&quot;lineno&quot;&gt;59&lt;/span&gt; 	  }
&lt;span class=&quot;lineno&quot;&gt;60&lt;/span&gt; 	  return _instance;
&lt;span class=&quot;lineno&quot;&gt;61&lt;/span&gt;    };
&lt;span class=&quot;lineno&quot;&gt;62&lt;/span&gt; 	virtual PC* makePC() {}//返回一台PC
&lt;span class=&quot;lineno&quot;&gt;63&lt;/span&gt; 	virtual CPU* createCPU() { return (CPU*) new IBMCPU }//override,生产一个IBMCPU
&lt;span class=&quot;lineno&quot;&gt;64&lt;/span&gt; 	virtual graphics_card* createCard() { return (graphics_card*) new IBMCard}//override,生产一个IBM显卡
&lt;span class=&quot;lineno&quot;&gt;65&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;66&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;67&lt;/span&gt; //想要自己组装PC的客户
&lt;span class=&quot;lineno&quot;&gt;68&lt;/span&gt; class Client {
&lt;span class=&quot;lineno&quot;&gt;69&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt;70&lt;/span&gt; 	//组装机器，传入一个工厂参数
&lt;span class=&quot;lineno&quot;&gt;71&lt;/span&gt; 	PC* assemblePC(abstract_factory* factory) {
&lt;span class=&quot;lineno&quot;&gt;72&lt;/span&gt; 		//拿到一个PC实例
&lt;span class=&quot;lineno&quot;&gt;73&lt;/span&gt; 		PC* myPC = factory.makePC();
&lt;span class=&quot;lineno&quot;&gt;74&lt;/span&gt; 		CPU* myCPU = factory.createCPU();
&lt;span class=&quot;lineno&quot;&gt;75&lt;/span&gt; 		Card* myCard = factory.createCard();
&lt;span class=&quot;lineno&quot;&gt;76&lt;/span&gt; 		myPC.addCPU(myPC);
&lt;span class=&quot;lineno&quot;&gt;77&lt;/span&gt; 		myPC.addCard(myCard);
&lt;span class=&quot;lineno&quot;&gt;78&lt;/span&gt; 		return PC
&lt;span class=&quot;lineno&quot;&gt;79&lt;/span&gt; 	}
&lt;span class=&quot;lineno&quot;&gt;80&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt;81&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;82&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;83&lt;/span&gt; int main() {
&lt;span class=&quot;lineno&quot;&gt;84&lt;/span&gt; 	Client* me = new Client;
&lt;span class=&quot;lineno&quot;&gt;85&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt;86&lt;/span&gt; 	//没有单例模式的工厂
&lt;span class=&quot;lineno&quot;&gt;87&lt;/span&gt; 	abstract_factory* intel = new Intel;
&lt;span class=&quot;lineno&quot;&gt;88&lt;/span&gt; 	//获得一台intel配置的PC
&lt;span class=&quot;lineno&quot;&gt;89&lt;/span&gt; 	PC* myPC = me.assemblePC(intel);
&lt;span class=&quot;lineno&quot;&gt;90&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt;91&lt;/span&gt; 	或者
&lt;span class=&quot;lineno&quot;&gt;92&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt;93&lt;/span&gt; 	//有单例模式的工厂,不能直接new
&lt;span class=&quot;lineno&quot;&gt;94&lt;/span&gt; 	abstract_factory* IBM = IBM::getInstance();
&lt;span class=&quot;lineno&quot;&gt;95&lt;/span&gt; 	//获得一台IBM配置的PC
&lt;span class=&quot;lineno&quot;&gt;96&lt;/span&gt; 	PC* myPC = me.assemblePC(IBM);
&lt;span class=&quot;lineno&quot;&gt;97&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt;98&lt;/span&gt; 	return 0;
&lt;span class=&quot;lineno&quot;&gt;99&lt;/span&gt; }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;section-2&quot;&gt;抽象工厂：&lt;/h4&gt;
&lt;p&gt;    上面的abstract_factory就是抽象工厂，&lt;code&gt;它提供了一系列相关或者相互依赖的接口，而不用指定他们具体的类&lt;/code&gt;。上面代码中用户只需要往assemblePC传入不同的abstract_factory子类就能得到配置不同的电脑,因为它们的接口都是一样的（createCPU和createCard），抽象工厂生产一个系统的各个部件。所以，抽象工厂一般适用于以下场景：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个系统要由多个产品系列中的一个来配置时（我的PC要么用Intel配置，要么用IBM配置）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;    简而言之，抽象工厂就是在多种系列产品加工厂上再抽象出的一个工厂，方便实现为用户配置提供统一接口。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;工厂方法&lt;/h4&gt;
&lt;p&gt;    上面abstract_factory中的方法（32、33、34行）便是工厂方法，&lt;code&gt;定义一个用于创建对象的接口，让子类决定实例化哪一个类。它使一个类的实例化延迟到子类。&lt;/code&gt;createCPU()创建一个CPU对象，但是Intel还是IBM呢？它只能延迟到它的子类(Intel工厂或者IBM工厂)来实现了，但接口都是一样的。这个还是挺好理解的。&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;单例模式&lt;/h4&gt;
&lt;p&gt;    上面IBM工厂(47行)采用了单例模式，&lt;code&gt;它保证了整个系统中只有一个IBM工厂实例&lt;/code&gt;，直接看代码应该可以明白是如何实现的。这与实际情况也相符合，如果工厂需要统计它生产了多少CPU，那就得用单例模式了。不然用户随便new出很多个Intel工厂的话统计就乱套了。&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;例子二&lt;/h4&gt;
&lt;p&gt;    接下来的例子讲述容易和抽象工厂混淆的生成器模式(Builder),同样针对上面的场景。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;  1&lt;/span&gt; //PC
&lt;span class=&quot;lineno&quot;&gt;  2&lt;/span&gt; class PC {
&lt;span class=&quot;lineno&quot;&gt;  3&lt;/span&gt; 	virtual void addCPU(CPU*) {}//装配CPU
&lt;span class=&quot;lineno&quot;&gt;  4&lt;/span&gt; 	virtual void addCard(Card*) {}//装配显卡
&lt;span class=&quot;lineno&quot;&gt;  5&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;  6&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;  7&lt;/span&gt; //CPU类
&lt;span class=&quot;lineno&quot;&gt;  8&lt;/span&gt; class CPU {}
&lt;span class=&quot;lineno&quot;&gt;  9&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 10&lt;/span&gt; //显卡类
&lt;span class=&quot;lineno&quot;&gt; 11&lt;/span&gt; class Card{}
&lt;span class=&quot;lineno&quot;&gt; 12&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 13&lt;/span&gt; //Intel工艺的CPU
&lt;span class=&quot;lineno&quot;&gt; 14&lt;/span&gt; class IntelCPU : public CPU {
&lt;span class=&quot;lineno&quot;&gt; 15&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt; 16&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 17&lt;/span&gt; //IBM工艺的CPU
&lt;span class=&quot;lineno&quot;&gt; 18&lt;/span&gt; class IBMCPU : public CPU {
&lt;span class=&quot;lineno&quot;&gt; 19&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt; 20&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 21&lt;/span&gt; //Intel工艺的显卡
&lt;span class=&quot;lineno&quot;&gt; 22&lt;/span&gt; class IntelCard : public Card {
&lt;span class=&quot;lineno&quot;&gt; 23&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt; 24&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 25&lt;/span&gt; //IBM工艺的显卡
&lt;span class=&quot;lineno&quot;&gt; 26&lt;/span&gt; class IBMCard : public Card {
&lt;span class=&quot;lineno&quot;&gt; 27&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt; 28&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 29&lt;/span&gt; //生成器，负责生产、组成并返回PC
&lt;span class=&quot;lineno&quot;&gt; 30&lt;/span&gt; class Builder {
&lt;span class=&quot;lineno&quot;&gt; 31&lt;/span&gt; 	//返回一台PC，特别注意这个方法，后文会讲到
&lt;span class=&quot;lineno&quot;&gt; 32&lt;/span&gt; 	virtual PC* getPC() {return 0};
&lt;span class=&quot;lineno&quot;&gt; 33&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt; 34&lt;/span&gt; 	virtual void buildCPU(){}//制作CPU
&lt;span class=&quot;lineno&quot;&gt; 35&lt;/span&gt; 	virtual void buildCard(){}//制作显卡
&lt;span class=&quot;lineno&quot;&gt; 36&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt; 37&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 38&lt;/span&gt; //Intel生成器
&lt;span class=&quot;lineno&quot;&gt; 39&lt;/span&gt; class Intel : public Builder {
&lt;span class=&quot;lineno&quot;&gt; 40&lt;/span&gt; private:
&lt;span class=&quot;lineno&quot;&gt; 41&lt;/span&gt; 	PC* pc;
&lt;span class=&quot;lineno&quot;&gt; 42&lt;/span&gt; 	void assembleCPU(CPU*) {}//组装CPU
&lt;span class=&quot;lineno&quot;&gt; 43&lt;/span&gt; public:
&lt;span class=&quot;lineno&quot;&gt; 44&lt;/span&gt; 	virtual void buildCPU(){
&lt;span class=&quot;lineno&quot;&gt; 45&lt;/span&gt; 		CPU* cpu = createCPU()//伪代码，表示生产了一个CPU，它可以跟上面的抽象工厂一起使用，但这个先忽略
&lt;span class=&quot;lineno&quot;&gt; 46&lt;/span&gt; 		assembleCPU(cpu);//组装CPU
&lt;span class=&quot;lineno&quot;&gt; 47&lt;/span&gt; 	}//制作CPU并组装
&lt;span class=&quot;lineno&quot;&gt; 48&lt;/span&gt; 	virtual void buildCard(){}//制作显卡
&lt;span class=&quot;lineno&quot;&gt; 49&lt;/span&gt; 	//返回一个PC
&lt;span class=&quot;lineno&quot;&gt; 50&lt;/span&gt; 	virtual PC* getPC() {return pc};
&lt;span class=&quot;lineno&quot;&gt; 51&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt; 52&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 53&lt;/span&gt; //想要自己组装PC的客户A
&lt;span class=&quot;lineno&quot;&gt; 54&lt;/span&gt; class ClientA {
&lt;span class=&quot;lineno&quot;&gt; 55&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt; 56&lt;/span&gt; 	//组装机器，传入一个生成器参数
&lt;span class=&quot;lineno&quot;&gt; 57&lt;/span&gt; 	PC* assemblePC(Builder* builder) {
&lt;span class=&quot;lineno&quot;&gt; 58&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt; 59&lt;/span&gt; 		//只装一个CPU
&lt;span class=&quot;lineno&quot;&gt; 60&lt;/span&gt; 		builder.buildCPU();
&lt;span class=&quot;lineno&quot;&gt; 61&lt;/span&gt; 		
&lt;span class=&quot;lineno&quot;&gt; 62&lt;/span&gt; 		//装一个显卡
&lt;span class=&quot;lineno&quot;&gt; 63&lt;/span&gt; 		builder.buildCard();
&lt;span class=&quot;lineno&quot;&gt; 64&lt;/span&gt; 		
&lt;span class=&quot;lineno&quot;&gt; 65&lt;/span&gt; 		//获得PC
&lt;span class=&quot;lineno&quot;&gt; 66&lt;/span&gt; 		return builder.getPC();
&lt;span class=&quot;lineno&quot;&gt; 67&lt;/span&gt; 	}
&lt;span class=&quot;lineno&quot;&gt; 68&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt; 69&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt; 70&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 71&lt;/span&gt; //想要自己组装PC的客户B
&lt;span class=&quot;lineno&quot;&gt; 72&lt;/span&gt; class ClientB {
&lt;span class=&quot;lineno&quot;&gt; 73&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt; 74&lt;/span&gt; 	//组装机器，传入一个生成器参数
&lt;span class=&quot;lineno&quot;&gt; 75&lt;/span&gt; 	PC* assemblePC(Builder* builder) {
&lt;span class=&quot;lineno&quot;&gt; 76&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt; 77&lt;/span&gt; 		//一口气装了3个CPU
&lt;span class=&quot;lineno&quot;&gt; 78&lt;/span&gt; 		builder.buildCPU();
&lt;span class=&quot;lineno&quot;&gt; 79&lt;/span&gt; 		builder.buildCPU();
&lt;span class=&quot;lineno&quot;&gt; 80&lt;/span&gt; 		builder.buildCPU();
&lt;span class=&quot;lineno&quot;&gt; 81&lt;/span&gt; 		
&lt;span class=&quot;lineno&quot;&gt; 82&lt;/span&gt; 		//装一个显卡
&lt;span class=&quot;lineno&quot;&gt; 83&lt;/span&gt; 		builder.buildCard();
&lt;span class=&quot;lineno&quot;&gt; 84&lt;/span&gt; 		
&lt;span class=&quot;lineno&quot;&gt; 85&lt;/span&gt; 		//获得PC
&lt;span class=&quot;lineno&quot;&gt; 86&lt;/span&gt; 		return builder.getPC();
&lt;span class=&quot;lineno&quot;&gt; 87&lt;/span&gt; 	}
&lt;span class=&quot;lineno&quot;&gt; 88&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt; 89&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt; 90&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 91&lt;/span&gt; //用户开始使用
&lt;span class=&quot;lineno&quot;&gt; 92&lt;/span&gt; int main() {
&lt;span class=&quot;lineno&quot;&gt; 93&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 94&lt;/span&gt; 	PC* myPC;
&lt;span class=&quot;lineno&quot;&gt; 95&lt;/span&gt; 	Builder* IntelBuilder = new Intel;
&lt;span class=&quot;lineno&quot;&gt; 96&lt;/span&gt; 	ClientA* me = new ClientA
&lt;span class=&quot;lineno&quot;&gt; 97&lt;/span&gt; 	PC = me.assemblePC(IntelBuilder);
&lt;span class=&quot;lineno&quot;&gt; 98&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt; 99&lt;/span&gt; 	return 0;
&lt;span class=&quot;lineno&quot;&gt;100&lt;/span&gt; }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;section-6&quot;&gt;生成器模式&lt;/h4&gt;
&lt;p&gt;    生成器模式定义：&lt;code&gt;将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示&lt;/code&gt;。上面代码乍一看跟抽象工厂差不多，只是把factory换成了builder。但其实本质是不一样的。在生成器模式下有三种角色:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Product(PC)：需要构造的复杂对象&lt;/li&gt;
  &lt;li&gt;Builder(生产和实现装配的Intel,IBM)：为创建Product各个部件指定抽象接口。&lt;/li&gt;
  &lt;li&gt;Director(Client,负责控制装机流程的)：构造一个使用Builder接口的对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;    跟抽象工厂对比：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ClientA和ClientB是看不到CPU,Card这两个部件的。它只能调用builder去装机，但装的具体细节全由builder（Intel）控制，用户(Director)完全不知道，director只能控制装机流程（要装几个CPU，几个显卡）。&lt;/li&gt;
  &lt;li&gt;抽象工厂一开始就获得了构建对象(PC)，而生成器模式是一步一步装载PC，最后才返回给用户PC。这个从时间点上不一样。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;    再回过头去看生成器的定义，构建(CPU的生产和装载具体做法全都封装在了Builder里)和表示(Director通过不同的实现制造出不同的Product)分离。同样的构建过程(同一个builder)可以创建不同表示(3个CPU的PC还是1个CPU的PC)。&lt;/p&gt;

&lt;h4 id=&quot;section-7&quot;&gt;生成器模式和抽象工厂的对比&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;两者都能构建复杂对象。但抽象工厂着重于构建相同系列的部件供给用户使用，用户爱怎么倒腾不关它的事（有用户喜欢把CPU插在内存插槽上或者其他奇奇怪怪的操作），而生成器着重于构建一个产品，它将产品具体装配封装起来，用户只能控制装载流程，但不能控制具体操作(你不能把CPU插在内存上，你只能决定需要几个CPU)。&lt;/li&gt;
  &lt;li&gt;根据上一条和代码，可以看出，抽象工厂是立马将产品生成，而生成器是到最后一步才把产品生成。&lt;/li&gt;
&lt;/ul&gt;

    </content>
  </entry>
  
  <entry>
    <title>设计模式学习一</title>
    <link href="/study/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B8%80/"/>
    <updated>2015-06-01T00:00:00+08:00</updated>
    <id>/study/设计模式学习一</id>
    <author>
      <name>Carson Lin</name>
      <uri>/</uri>
      <email>carsonxiaoyang@gmail.com</email>
    </author>
    <content type="html">
      
      &lt;p&gt;    最近实习面试几乎场场都会问到设计模式，之前虽然也有用到过，但没有系统地学习过，借此机会补下课。本文仅是基于一个初学小白理解的总结，可能有些漏洞，欢迎纠错。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section&quot;&gt;设计模式分类：&lt;/h3&gt;
&lt;p&gt;常见设计模式有23种，分别为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;创建型：5种&lt;/li&gt;
  &lt;li&gt;结构型：7种&lt;/li&gt;
  &lt;li&gt;行为型：11种&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;创建型模式&lt;/h3&gt;

&lt;p&gt;    创建型模式，按照《设计模式》一书中的说明:&lt;br /&gt;&lt;/p&gt;
&lt;pre&gt;
	&lt;code&gt;
	创建型模式抽象了实例化过程，他们帮助一个系统独立于如何创建、组合和表示它的那些对象。
	一个类创建型模式使用继承改变被实例化的类，而一个对象创建型模式将实例化委托给另一个对象。
	&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;    一开始看这段话的时候没怎么懂，通过形象的例子之后才明白。这里引用书上的例子。你玩一个走迷宫游戏，这里的迷宫游戏就是上面所说的&lt;code&gt;系统&lt;/code&gt;，你可以用createMaze()函数配置这个游戏的场景（实现创建墙壁，门，出入口等操作），有&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;普通迷宫&lt;/li&gt;
  &lt;li&gt;魔法型迷宫（墙壁有魔法效果）&lt;/li&gt;
  &lt;li&gt;HelloKitty主题迷宫&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;    最直接的做法就是在createMaze()里硬编码，这样每次要更换场景的时候就不得不重新更改代码。如果我们能在上面三个迷宫类型上面再抽象出一个类Abstract Maze,就能通过多态将代表三个迷宫场景的子类通过Abstract Maze传递给createMaze()。这样根本不需要改变createMaze()的代码就能实现三种模式的转换。这个就是创建型模式，抽象了实例化过程（迷宫场景的生成），系统独立于对象的创建，组合（创建迷宫的使用者不需要知道对象的具体实现，它只需要接收一个抽象类参数并调用接口就行了），在后文会说明这Abstract Maze其实就是抽象工厂，而createMaze()就是工厂方法。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;结构性模式&lt;/h3&gt;
&lt;p&gt;    顾名思义，结构性模式就是负责组合类和对象，目的是获得更大的结构。结构性类模式采用继承机制来组合接口和实现。根据《设计模式》一书中所说，最简单的例子就是采用多重继承使得子类获得所有父类的性质。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;行为模式&lt;/h3&gt;
&lt;p&gt;    行为模式涉及到算法和对象间职责的分配。行为模式不仅描述对象或类的模式，还描述他们之间的通信模式。这些模式刻划了在运行时难以跟踪的控制流。他们将你的注意力从控制流转移到对象间的联系方式上。—《设计模式》&lt;br /&gt;
    行为类模式采用类继承机制实现在类间分配任务，行为对象通过对象复合以实现更高级的行为。一言以蔽之，行为模式是为了实现更复杂的算法或行为。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;最后&lt;/h3&gt;
&lt;p&gt;    本文仅仅是对三大类设计模式进行了一次梗概，具体每种设计模式是什么样的将在后续的学习中一一阐述。&lt;/p&gt;

    </content>
  </entry>
  
  <entry>
    <title>依图面试总结</title>
    <link href="/study/%E4%BE%9D%E5%9B%BE%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <updated>2015-05-27T00:00:00+08:00</updated>
    <id>/study/依图面试总结</id>
    <author>
      <name>Carson Lin</name>
      <uri>/</uri>
      <email>carsonxiaoyang@gmail.com</email>
    </author>
    <content type="html">
      
      &lt;h3 id=&quot;section&quot;&gt;一面：&lt;/h3&gt;
&lt;p&gt;    1、LeetCode原题，判断一个数是不是2的幂。&lt;br /&gt;
    当时没想起来是LeetCode原题，直观地利用二进制表示是否只有一个1的做法，因为如果是2的幂的话二进制表示肯定只有一个1，这样做法是O(32)的。后来面试官问有什么可以优化的，我没直接想出来，但给出了思考方向。先是试探性地问面试官他现在是希望我想出一个一步到位的算法，得到肯定回答后可以排除一些奇怪的想法，那么只剩下两种可能性。一种是一步算出有多少个1，另一种是消掉其中一个1然后看是否还有1。显然第一种是走不通的，那么只省下第二种可能性，面试官表示了赞同。在经过这样一番沟通后，面试官提示我可以考虑下和x-1的关系，这个时候我才想起这事leetCode原题，但时间太久还是没想起来，现场试验后发现这就是消掉最右边一个1的做法。&lt;br /&gt;
    2、下围棋的情况判断&lt;br /&gt;
    面试官拿了一张纸画了一个围棋盘，然后用黑白磁铁当做棋子摆出个棋局。是围棋规则，要让对手没一口活棋（就是他落哪都不能围住我但自己会被围）。然后又画了一个空格，两个空格，三个空格，四个空格及其以上的情况，其实问题的关键是黑棋只要能构建出两个独立的联通分量的话他就能活（不被围死）。但当时对规则理解实在没咋懂，加上中午没睡觉所以有点懵，没找出关键。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;二面：&lt;/h3&gt;
&lt;p&gt;    1、给一个三维坐标A，找另一个高低位相同的三维坐标，使得离A最近。&lt;br /&gt;
    根据距离公式可以得出三个分量独立，然后每个分量只需要16次枚举就行。当时没想到按最直接的想法想就行，想偏了。在提示下才做出来的。接下来是写代码，这题涉及到字符串和整型的互相转化，写了四个函数。写得比较慢，但好险没出bug，弥补了前面的失误。&lt;br /&gt;
    2、LeetCode原题，给一个字符串，找出最长子串使得其实没一个字符重复&lt;br /&gt;
    LeetCode原题，直接用个数组标记就行，但实在很困，语言表达得很渣。这题没写代码。&lt;br /&gt;
    3、给一个整型数组，找出能整除p的子数组的个数。&lt;br /&gt;
    一开始想复杂了，甚至往动态规划上想去了，其实也是从最直接的做法优化。O（N^2）枚举所有情况，用前缀和(sum[j] - sum[i]) mod p判断，代入问题转换成将前缀和mod p之后看有多少对相同的。这个用个统排计算一下即可，当时漏了一种情况就是sum[i] mod p == 0时要单独加上（长度为1的也符合条件）。这个代码也比较好实现。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;    被突然问了数分成绩，可能是因为第三题看出了这个数学基础不扎实… &lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-3&quot;&gt;三面:&lt;/h3&gt;
&lt;p&gt;    1、写最短路&lt;br /&gt;
    写了个最好写的floyed..&lt;br /&gt;
    2、证明最短路
    写了之后发现自己把自己坑了，竟然要求证明…实在不知道从何下手，在面试官提醒下才加了一维F[i][j][k]用动态规划的方法写出了转移方程。最后问了一个为什么第三维可以省略，这个实在不知道怎么表达，最后他跟我说只需要答在第k次计算时f[i][j]的值还是表示k-1，即没有被更新过即可。&lt;br /&gt;
    3、LeetCode原题，ZigZag打印&lt;br /&gt;
    LeetCode原题，方阵打印。先枚举对角线x + y的和，在逐个遍历即可。当时脑子不清醒用了m,n两个变量变成不是方阵了。&lt;br /&gt;
    4、介绍项目&lt;br /&gt;
    就简单地介绍了下传承，还是被问到了老问题，遇到的最大困难是什么。我答了一是项目协同工作以及我们怎么克服，二是资料审查，当前只能人工，后期打算通过用户筛选。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;    被面试官问了句“数学是不是没学好”…竟然被发现了…&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-5&quot;&gt;四面：&lt;/h3&gt;
&lt;p&gt;    1、两个排好序的数组，求交集&lt;br /&gt;
    用两个光标分别扫描A,B数组，如果A[i] == B[j]，那么就是目标交集，i++,j++。否则，加那个比较小的。这样是O(N)的&lt;br /&gt;
    2、如果一个数组很大，有100w，另外一个很小,只有10&lt;br /&gt;
    扫描小的，然后二分大的，这样是O(nLogM)&lt;br /&gt;
    3、考虑一个1T的文本数据存储，硬盘7200转，I/O 100MB/s，内存16GB，带宽10GB。输入一个数，判断是否存在于文本中。问1s可以满足多少次访问&lt;br /&gt;
    给跪了，磁盘访问这个完全不会，现场教的，要用B+树思想，其实就是建立索引，16GB的索引，然后再读入索引对应的序列。在这样之上读入对应序列的时间几乎可以忽略不计，即没有用到100MB/s那么大的I/O，因此可以减少索引大小，让我算减少多少。我就列方程解，不知道为什么死活解不出来…可能饿得困得头昏眼花了…最后好险面试官放过我了。说我这种算法是学生思维，真正在工程里这是最简单的问题，你需要知道这个东西真正的瓶颈在哪里。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;    边吃饭边面的，脑子已经混了。加上身边很吵，根本不知道自己在想什么，感觉完全跪了。但可能是因为基础的算法想得比较快，而且主动拿出纸笔写代码。（想不出不敢吃饭呀….）最后还是让过了。&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;总结：&lt;/h2&gt;
&lt;p&gt;    总的来说这次没有什么压力，所以面得比较轻松，但是一轮轮车轮战体力脑子实在是个问题。最后都感觉眼前一片模糊了，不过好险坚持了下来。这或许有压力测试的成分吧，所以坚决不放弃还是很有用的。&lt;/p&gt;

    </content>
  </entry>
  
  
</feed>