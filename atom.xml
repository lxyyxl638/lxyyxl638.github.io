<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title>Carson的博客</title>
  <generator uri="https://github.com/jekyll/jekyll">Jekyll v2.4.0</generator>
    <icon>/apple-touch-icon-precomposed.png</icon>
  <subtitle>My Life</subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="/" rel="alternate" type="text/html"/>
  <updated>2015-07-11T12:26:49+08:00</updated>
  <id>/</id>
  <author>
    <name>Carson Lin</name>
    <uri>/</uri>
    <email>carsonxiaoyang@gmail.com</email>
  </author>

  
  <entry>
    <title>设计模式学习一</title>
    <link href="/study/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B8%80/"/>
    <updated>2015-06-01T00:00:00+08:00</updated>
    <id>/study/设计模式学习一</id>
    <author>
      <name>Carson Lin</name>
      <uri>/</uri>
      <email>carsonxiaoyang@gmail.com</email>
    </author>
    <content type="html">
      
      &lt;p&gt;    最近实习面试几乎场场都会问到设计模式，之前虽然也有用到过，但没有系统地学习过，借此机会补下课。本文仅是基于一个初学小白理解的总结，可能有些漏洞，欢迎纠错。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section&quot;&gt;设计模式分类：&lt;/h3&gt;
&lt;p&gt;常见设计模式有23种，分别为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;创建型：5种&lt;/li&gt;
  &lt;li&gt;结构型：7种&lt;/li&gt;
  &lt;li&gt;行为型：11种&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;创建型模式&lt;/h3&gt;

&lt;p&gt;    创建型模式，按照《设计模式》一书中的说明:&lt;br /&gt;&lt;/p&gt;
&lt;pre&gt;
	&lt;code&gt;
	创建型模式抽象了实例化过程，他们帮助一个系统独立于如何创建、组合和表示它的那些对象。
	一个类创建型模式使用继承改变被实例化的类，而一个对象创建型模式将实例化委托给另一个对象。
	&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;    一开始看这段话的时候没怎么懂，通过形象的例子之后才明白。这里引用书上的例子。你玩一个走迷宫游戏，这里的迷宫游戏就是上面所说的&lt;code&gt;系统&lt;/code&gt;，你可以用createMaze()函数配置这个游戏的场景（实现创建墙壁，门，出入口等操作），有&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;普通迷宫&lt;/li&gt;
  &lt;li&gt;魔法型迷宫（墙壁有魔法效果）&lt;/li&gt;
  &lt;li&gt;HelloKitty主题迷宫&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;    最直接的做法就是在createMaze()里硬编码，这样每次要更换场景的时候就不得不重新更改代码。如果我们能在上面三个迷宫类型上面再抽象出一个类Abstract Maze,就能通过多态将代表三个迷宫场景的子类通过Abstract Maze传递给createMaze()。这样根本不需要改变createMaze()的代码就能实现三种模式的转换。这个就是创建型模式，抽象了实例化过程（迷宫场景的生成），系统独立于对象的创建，组合（创建迷宫的使用者不需要知道对象的具体实现，它只需要接收一个抽象类参数并调用接口就行了），在后文会说明这Abstract Maze其实就是抽象工厂，而createMaze()就是工厂方法。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;结构性模式&lt;/h3&gt;
&lt;p&gt;    顾名思义，结构性模式就是负责组合类和对象，目的是获得更大的结构。结构性类模式采用继承机制来组合接口和实现。根据《设计模式》一书中所说，最简单的例子就是采用多重继承使得子类获得所有父类的性质。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;行为模式&lt;/h3&gt;
&lt;p&gt;    行为模式涉及到算法和对象间职责的分配。行为模式不仅描述对象或类的模式，还描述他们之间的通信模式。这些模式刻划了在运行时难以跟踪的控制流。他们将你的注意力从控制流转移到对象间的联系方式上。—《设计模式》&lt;br /&gt;
    行为类模式采用类继承机制实现在类间分配任务，行为对象通过对象复合以实现更高级的行为。一言以蔽之，行为模式是为了实现更复杂的算法或行为。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;最后&lt;/h3&gt;
&lt;p&gt;    本文仅仅是对三大类设计模式进行了一次梗概，具体每种设计模式是什么样的将在后续的学习中一一阐述。&lt;/p&gt;

    </content>
  </entry>
  
  <entry>
    <title>依图面试总结</title>
    <link href="/study/%E4%BE%9D%E5%9B%BE%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <updated>2015-05-27T00:00:00+08:00</updated>
    <id>/study/依图面试总结</id>
    <author>
      <name>Carson Lin</name>
      <uri>/</uri>
      <email>carsonxiaoyang@gmail.com</email>
    </author>
    <content type="html">
      
      &lt;h3 id=&quot;section&quot;&gt;一面：&lt;/h3&gt;
&lt;p&gt;    1、LeetCode原题，判断一个数是不是2的幂。&lt;br /&gt;
    当时没想起来是LeetCode原题，直观地利用二进制表示是否只有一个1的做法，因为如果是2的幂的话二进制表示肯定只有一个1，这样做法是O(32)的。后来面试官问有什么可以优化的，我没直接想出来，但给出了思考方向。先是试探性地问面试官他现在是希望我想出一个一步到位的算法，得到肯定回答后可以排除一些奇怪的想法，那么只剩下两种可能性。一种是一步算出有多少个1，另一种是消掉其中一个1然后看是否还有1。显然第一种是走不通的，那么只省下第二种可能性，面试官表示了赞同。在经过这样一番沟通后，面试官提示我可以考虑下和x-1的关系，这个时候我才想起这事leetCode原题，但时间太久还是没想起来，现场试验后发现这就是消掉最右边一个1的做法。&lt;br /&gt;
    2、下围棋的情况判断&lt;br /&gt;
    面试官拿了一张纸画了一个围棋盘，然后用黑白磁铁当做棋子摆出个棋局。是围棋规则，要让对手没一口活棋（就是他落哪都不能围住我但自己会被围）。然后又画了一个空格，两个空格，三个空格，四个空格及其以上的情况，其实问题的关键是黑棋只要能构建出两个独立的联通分量的话他就能活（不被围死）。但当时对规则理解实在没咋懂，加上中午没睡觉所以有点懵，没找出关键。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;二面：&lt;/h3&gt;
&lt;p&gt;    1、给一个三维坐标A，找另一个高低位相同的三维坐标，使得离A最近。&lt;br /&gt;
    根据距离公式可以得出三个分量独立，然后每个分量只需要16次枚举就行。当时没想到按最直接的想法想就行，想偏了。在提示下才做出来的。接下来是写代码，这题涉及到字符串和整型的互相转化，写了四个函数。写得比较慢，但好险没出bug，弥补了前面的失误。&lt;br /&gt;
    2、LeetCode原题，给一个字符串，找出最长子串使得其实没一个字符重复&lt;br /&gt;
    LeetCode原题，直接用个数组标记就行，但实在很困，语言表达得很渣。这题没写代码。&lt;br /&gt;
    3、给一个整型数组，找出能整除p的子数组的个数。&lt;br /&gt;
    一开始想复杂了，甚至往动态规划上想去了，其实也是从最直接的做法优化。O（N^2）枚举所有情况，用前缀和(sum[j] - sum[i]) mod p判断，代入问题转换成将前缀和mod p之后看有多少对相同的。这个用个统排计算一下即可，当时漏了一种情况就是sum[i] mod p == 0时要单独加上（长度为1的也符合条件）。这个代码也比较好实现。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;    被突然问了数分成绩，可能是因为第三题看出了这个数学基础不扎实… &lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-3&quot;&gt;三面:&lt;/h3&gt;
&lt;p&gt;    1、写最短路&lt;br /&gt;
    写了个最好写的floyed..&lt;br /&gt;
    2、证明最短路
    写了之后发现自己把自己坑了，竟然要求证明…实在不知道从何下手，在面试官提醒下才加了一维F[i][j][k]用动态规划的方法写出了转移方程。最后问了一个为什么第三维可以省略，这个实在不知道怎么表达，最后他跟我说只需要答在第k次计算时f[i][j]的值还是表示k-1，即没有被更新过即可。&lt;br /&gt;
    3、LeetCode原题，ZigZag打印&lt;br /&gt;
    LeetCode原题，方阵打印。先枚举对角线x + y的和，在逐个遍历即可。当时脑子不清醒用了m,n两个变量变成不是方阵了。&lt;br /&gt;
    4、介绍项目&lt;br /&gt;
    就简单地介绍了下传承，还是被问到了老问题，遇到的最大困难是什么。我答了一是项目协同工作以及我们怎么克服，二是资料审查，当前只能人工，后期打算通过用户筛选。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;    被面试官问了句“数学是不是没学好”…竟然被发现了…&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-5&quot;&gt;四面：&lt;/h3&gt;
&lt;p&gt;    1、两个排好序的数组，求交集&lt;br /&gt;
    用两个光标分别扫描A,B数组，如果A[i] == B[j]，那么就是目标交集，i++,j++。否则，加那个比较小的。这样是O(N)的&lt;br /&gt;
    2、如果一个数组很大，有100w，另外一个很小,只有10&lt;br /&gt;
    扫描小的，然后二分大的，这样是O(nLogM)&lt;br /&gt;
    3、考虑一个1T的文本数据存储，硬盘7200转，I/O 100MB/s，内存16GB，带宽10GB。输入一个数，判断是否存在于文本中。问1s可以满足多少次访问&lt;br /&gt;
    给跪了，磁盘访问这个完全不会，现场教的，要用B+树思想，其实就是建立索引，16GB的索引，然后再读入索引对应的序列。在这样之上读入对应序列的时间几乎可以忽略不计，即没有用到100MB/s那么大的I/O，因此可以减少索引大小，让我算减少多少。我就列方程解，不知道为什么死活解不出来…可能饿得困得头昏眼花了…最后好险面试官放过我了。说我这种算法是学生思维，真正在工程里这是最简单的问题，你需要知道这个东西真正的瓶颈在哪里。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;    边吃饭边面的，脑子已经混了。加上身边很吵，根本不知道自己在想什么，感觉完全跪了。但可能是因为基础的算法想得比较快，而且主动拿出纸笔写代码。（想不出不敢吃饭呀….）最后还是让过了。&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;总结：&lt;/h2&gt;
&lt;p&gt;    总的来说这次没有什么压力，所以面得比较轻松，但是一轮轮车轮战体力脑子实在是个问题。最后都感觉眼前一片模糊了，不过好险坚持了下来。这或许有压力测试的成分吧，所以坚决不放弃还是很有用的。&lt;/p&gt;

    </content>
  </entry>
  
  
</feed>