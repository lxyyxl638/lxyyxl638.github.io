<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title>Carson的博客</title>
  <generator uri="https://github.com/jekyll/jekyll">Jekyll v2.4.0</generator>
    <icon>/apple-touch-icon-precomposed.png</icon>
  <subtitle>My Life</subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="/" rel="alternate" type="text/html"/>
  <updated>2015-07-25T13:57:30+08:00</updated>
  <id>/</id>
  <author>
    <name>Carson Lin</name>
    <uri>/</uri>
    <email>carsonxiaoyang@gmail.com</email>
  </author>

  
  <entry>
    <title>高可用聊天室构建实习故事I Nginx+FastCGI配置一</title>
    <link href="/study/Nginx+FastCGI%E9%85%8D%E7%BD%AE/"/>
    <updated>2015-07-19T00:00:00+08:00</updated>
    <id>/study/Nginx+FastCGI配置</id>
    <author>
      <name>Carson Lin</name>
      <uri>/</uri>
      <email>carsonxiaoyang@gmail.com</email>
    </author>
    <content type="html">
      
      &lt;h3 id=&quot;section&quot;&gt;起因：&lt;/h3&gt;
&lt;p&gt;    最近在某公司实习，Leader给了个2个月的项目考核能力。&lt;code&gt;实现一个webQQ，后台要用CGI并用C语言写，支持2W人同时在线，而且系统要高可用。资源是给了5台服务器&lt;/code&gt;。什么是CGI，如何运用5台服务器构建负载均衡等问题一下子扑面而来，之前虽然写过的网站不少，但都是用PHP并且是现成的框架，什么都封装好的，服务器端如何配置，到底是怎样一个流程完全不知道。只知道客户端发一个http请求到服务器，服务器用PHP处理完业务逻辑之后再发回给客户端。这次是一个沉淀的机会，所以坚持写下这段实习故事，当做总结。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;初步接触：&lt;/h3&gt;
&lt;p&gt;    暂时先抛开2W并发，高可用等要求，第一步我们当然得先实现功能，就是得让网站跑起来。这便引出了第一个问题：&lt;code&gt;什么是CGI编程&lt;/code&gt;？&lt;/p&gt;

&lt;h3 id=&quot;cgi&quot;&gt;CGI是什么？&lt;/h3&gt;
&lt;p&gt;    CGI（common gateway interface），通用网关接口协议。一个网站访问的过程大致是这样的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;客户端（浏览器）发送一个http请求（一般通过TCP）到服务器（Apache,Nginx等）80端口&lt;/li&gt;
  &lt;li&gt;服务器进程接受到http报文后，经过处理（将一些信息写进环境变量）然后调用后台CGI程序，把处理过的信息传入CGI程序，这中间采用标准输入输出，服务器标准输出对应CGI程序的标准输入&lt;/li&gt;
  &lt;li&gt;CGI程序处理完业务逻辑后通过标准输出返回给服务器，服务器再返回给客户端（浏览器）&lt;/li&gt;
  &lt;li&gt;服务器断开连接
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;    这里的CGI输入输出的介质是采用端口监听。
    更详细地步骤如下：
&lt;img src=&quot;/images/2015-07-19-1.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;(1)浏览器通过URL连接到服务器&lt;/li&gt;
  &lt;li&gt;(2)服务器将URL翻译成路径和文件名&lt;/li&gt;
  &lt;li&gt;(3)服务器将URL指向一个应该程序而不是一个静态文件&lt;/li&gt;
  &lt;li&gt;(4)服务器为应用程序执行做准备&lt;/li&gt;
  &lt;li&gt;(5)应用程序执行，读取标准输入和有关环境变量&lt;/li&gt;
  &lt;li&gt;(6)应用程序准备进行标准输出&lt;/li&gt;
  &lt;li&gt;(7)应用程序发送标准输出并结束&lt;/li&gt;
  &lt;li&gt;(8)服务器断开连接&lt;/li&gt;
  &lt;li&gt;(9)浏览器显示应用程序的输出结果&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cgi-1&quot;&gt;为什么要用CGI？&lt;/h3&gt;
&lt;p&gt;    使用CGI可以使后台服务程序和服务器极大解耦。服务器的崩溃并不会影响后台服务（这里的后台服务是指上图服务器之后的层面）。这里可以对比一下Php在Apache的运行模式。可以参考&lt;a href=&quot;http://www.cnblogs.com/phphuaibei/archive/2011/09/13/2174927.html&quot;&gt;php原理&lt;/a&gt;或者其他资料。简单来说，就是Php在Apache上有三种运行模式&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Apache模块DLL&lt;/li&gt;
  &lt;li&gt;CGI&lt;/li&gt;
  &lt;li&gt;FastCGI&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;    第三种后面再详述，第一种是将PHP作为Apache的一个模块来运行，Apache启动的时候会启动多个服务器进程（这又涉及到于Apache的preforker和worker模式），而Php解释引擎也集成在里面。Php作为Apache的一个模块，必须寄生在Apache上财能运行。&lt;br /&gt;
    所以，使用CGI就不同上述模式，它可以把后台服务和Apache解耦。&lt;/p&gt;

&lt;h3 id=&quot;fastcgi&quot;&gt;FastCGI&lt;/h3&gt;
&lt;p&gt;    那么CGI又有什么缺点呢？从上述CGI的运行原理来看，每一条http请求都会有一次CGI程序的调用和退出。将CGI程序加载进内存，释放内存的代价是巨大的，也是十分浪费的。那么有一个很自然的想法，能不能把CGI程序设置成一开始就启动，弄成一个常驻进程，处理多次（注意，是多次同个http请求，不是多个）请求呢？。FastCGI就是这样一种机制。&lt;br /&gt;
&lt;br /&gt;
    先从感性上对比下CGI和FastCGI：
&lt;img src=&quot;/images/2015-07-19-2.jpg&quot; /&gt;
&lt;img src=&quot;/images/2015-07-19-3.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;    从上图可以看出，FastCGI多了一个进程管理器，在服务器启动时，启动进程管理器（Php对应PHP-FPM，C对应spawn-fcgi），进程管理器再去启动多个cgi进程（每个进程监听一个端口）。请求过程跟上面CGI一样，只是多了一层进程管理器转发而且请求返回结果后cgi进程不会退出。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;FastCGI的官方文档
&lt;a href=&quot;http://www.fastcgi.com/drupal/&quot;&gt;FastCGI的官方文档&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;nginxfastcgi&quot;&gt;Nginx+FastCGI&lt;/h3&gt;
&lt;p&gt;    在对CGI和FastCGI有一个基本的认识之后，我们从实例当下看下如何配置Nginx服务器+FastCGI,这里FastCGI用C/C++实现。
&lt;img src=&quot;/images/2015-07-19-4.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图是另外一种表示方法，这里的wraper就是所谓的进程管理器。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;环境部署（部分参考网上资料）&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;nginx的安装、部署与配置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;到nginx官网下载最新版本的nginx&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[安装]

根据README解压并安装
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; ./configure 
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt;     make
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt;     make install （默认安装到/usr/local/nginx）
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt;     [配置和管理]    
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt;     1）执行选项
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt;         -c &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;/path/to/config&amp;gt; 为 Nginx 指定一个配置文件，来代替缺省的。不输入则使用默认的配置文件。
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;11&lt;/span&gt;         -t 不运行，而仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。
&lt;span class=&quot;lineno&quot;&gt;12&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;13&lt;/span&gt;         -v 显示 nginx 的版本。
&lt;span class=&quot;lineno&quot;&gt;14&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;15&lt;/span&gt;         -V 显示 nginx 的版本，编译器版本和配置参数。
&lt;span class=&quot;lineno&quot;&gt;16&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;17&lt;/span&gt;  
&lt;span class=&quot;lineno&quot;&gt;18&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;19&lt;/span&gt;     2）检查配置文件
&lt;span class=&quot;lineno&quot;&gt;20&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;21&lt;/span&gt;         sudo ./nginx -t
&lt;span class=&quot;lineno&quot;&gt;22&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;23&lt;/span&gt;         nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok
&lt;span class=&quot;lineno&quot;&gt;24&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;25&lt;/span&gt;         nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful
&lt;span class=&quot;lineno&quot;&gt;26&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;27&lt;/span&gt;      3）启动 - 默认和特殊
&lt;span class=&quot;lineno&quot;&gt;28&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;29&lt;/span&gt;         /usr/local/nginx/sbin/nginx （默认启动方式）
&lt;span class=&quot;lineno&quot;&gt;30&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;31&lt;/span&gt;         /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf （指定配置文件启动）
&lt;span class=&quot;lineno&quot;&gt;32&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;33&lt;/span&gt;     4）查看nginx进程号（master是主进程）
&lt;span class=&quot;lineno&quot;&gt;34&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;35&lt;/span&gt;         ps -ef | grep nginx
&lt;span class=&quot;lineno&quot;&gt;36&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;37&lt;/span&gt;     5）重新加载配置文件
&lt;span class=&quot;lineno&quot;&gt;38&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;39&lt;/span&gt;         sudo kill -HUP [nginx主进程号]
&lt;span class=&quot;lineno&quot;&gt;40&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;41&lt;/span&gt;         通过系统的信号控制 Nginx
&lt;span class=&quot;lineno&quot;&gt;42&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;43&lt;/span&gt;         可以使用信号系统来控制主进程。默认，nginx 将其主进程的 pid 写入到 /usr/local/nginx/logs/nginx.pid 文件中。通过传递参数        给 ./configure 或使用 pid 指令，来改变该文件的位置。
&lt;span class=&quot;lineno&quot;&gt;44&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;45&lt;/span&gt;        主进程可以处理以下的信号：
&lt;span class=&quot;lineno&quot;&gt;46&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;47&lt;/span&gt;         命令 说明 备注
&lt;span class=&quot;lineno&quot;&gt;48&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;49&lt;/span&gt;         TERM, INT 快速关闭
&lt;span class=&quot;lineno&quot;&gt;50&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;51&lt;/span&gt;         QUIT 从容关闭
&lt;span class=&quot;lineno&quot;&gt;52&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;53&lt;/span&gt;         HUP 重载配置
&lt;span class=&quot;lineno&quot;&gt;54&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;55&lt;/span&gt; 用新的配置开始新的工作进程    从容关闭旧的工作进程
&lt;span class=&quot;lineno&quot;&gt;56&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;57&lt;/span&gt;         USR1 重新打开日志文件
&lt;span class=&quot;lineno&quot;&gt;58&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;59&lt;/span&gt;         USR2 平滑升级可执行程序
&lt;span class=&quot;lineno&quot;&gt;60&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;61&lt;/span&gt;         WINCH 从容关闭工作进程
&lt;span class=&quot;lineno&quot;&gt;62&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;63&lt;/span&gt;     6）默认目录结构
&lt;span class=&quot;lineno&quot;&gt;64&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;65&lt;/span&gt;         主目录：/usr/local/nginx/
&lt;span class=&quot;lineno&quot;&gt;66&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;67&lt;/span&gt;         配置目录：/usr/local/nginx/conf/
&lt;span class=&quot;lineno&quot;&gt;68&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;69&lt;/span&gt;         root目录：/usr/local/nginx/html/
&lt;span class=&quot;lineno&quot;&gt;70&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;71&lt;/span&gt;         可执行文件路径：/usr/local/nginx/sbin/&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;spawn_fastcgi的安装、部署与配置&lt;/p&gt;

    &lt;p&gt;spawn_fastcgi  https://github.com/lighttpd/spawn-fcgi&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; 下载以后解压并安装（请记得看README）
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt;     如果没有configure，请先执行./autogen.sh，生成configure
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt;     ./configure
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt;     make
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt;     编译好以后，将可执行文件移动到nginx的sbin目录下
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;11&lt;/span&gt;     cp ./src/spawn-fcgi /usr/local/nginx/sbin/ （cp到nginx的安装目录下）&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;fastcgi库的安装&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个库主要重载了printf和其他几个函数，是很小的一个库。重载printf用于输出流重定向，因为我们要把输出定向到进程管理器（spwan_fcgi）上&lt;br /&gt;
库地址 http://www.fastcgi.com/dist/fcgi.tar.gz&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; tar –zxvf fcgi.tar.gz
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; ./configure
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; make
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt; make install
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;6&lt;/span&gt; 编译时如出现，fcgio.cpp error &amp;#39;eof&amp;#39; was not declared in this scope
&lt;span class=&quot;lineno&quot;&gt;7&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;8&lt;/span&gt; 在/include/fcgio.h文件中加上 #include &lt;span class=&quot;nt&quot;&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;，然后再编译安装就通过了&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Demo和web发布&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[CGI程序]&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; #include &lt;span class=&quot;nt&quot;&gt;&amp;lt;fcgi_stdio.h&amp;gt;&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt; #include &lt;span class=&quot;nt&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt; int main() { 
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt; int count = 0; 
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt; while (FCGI_Accept() &amp;gt;= 0) { 
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt; printf(&amp;quot;Content-type: text/html\r\n&amp;quot; 
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt; &amp;quot;\r\n&amp;quot; 
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt; &amp;quot;&amp;quot; 
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt; &amp;quot;FastCGI Hello!&amp;quot; 
&lt;span class=&quot;lineno&quot;&gt;11&lt;/span&gt; &amp;quot;Request number %d running on host%s &amp;quot; 
&lt;span class=&quot;lineno&quot;&gt;12&lt;/span&gt; &amp;quot;Process ID: %d\n&amp;quot;, ++count, getenv(&amp;quot;SERVER_NAME&amp;quot;), getpid()); 
&lt;span class=&quot;lineno&quot;&gt;13&lt;/span&gt; } 
&lt;span class=&quot;lineno&quot;&gt;14&lt;/span&gt; return 0; 
&lt;span class=&quot;lineno&quot;&gt;15&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;16&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;17&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;18&lt;/span&gt; [编译]
&lt;span class=&quot;lineno&quot;&gt;19&lt;/span&gt; g++ demo.cc -o demo -lfcgi​&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;直接运行可执行文件，看看能否正常运行。如果出现缺少库libfcgi.so.0，则自己需要手动把/usr/local/lib/libfcgi.so.0库建立一个链接到/usr/lib/目录下：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; ln -s /usr/local/lib/libfcgi.so.0 /usr/lib/（或者把so的库路径添加到/etc/ld.so.conf，并执行ldconfig更新一下）&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Web发布&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;1）将CGI可执行程序移动到nginx的安装目录下 /usr/local/nginx/cgibin （文件夹不存在则自己创建） &lt;/p&gt;

&lt;p&gt;2）启动spawn-fcgi管理进程，并绑定server IP和端口（不要跟nginx的监听端口重合）&lt;/p&gt;

&lt;p&gt;Demo中使用&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; /usr/local/nginx/sbin/spawn-fcgi -a 127.0.0.1 -p 8088 -f /usr/local/nginx/cgibin/demo
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; 查看一下8088端口是否已成功：
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt; netstat -nap | grep 8088
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt; 或者
&lt;span class=&quot;lineno&quot;&gt;6&lt;/span&gt; lsof -i:8080
&lt;span class=&quot;lineno&quot;&gt;7&lt;/span&gt; ​&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3）更改nginx.conf配置文件，让nginx转发请求&lt;/p&gt;

&lt;p&gt;在http节点的子节点-“server节”点中下添加配置&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; location ~ \.cgi$ {
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; 	fastcgi_pass 127.0.0.1:8088; 
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; 	fastcgi_param SCRIPT_FILENAME fcgi$fastcgi_script_name;
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt; 	include fastcgi_params;
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt; }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4）打开浏览器输入
http://localhost/demo.cgi（这里只要后缀是.cgi就可以）&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;备注：&lt;/h3&gt;
&lt;p&gt;    注意上面代码中的&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; while (FCGI_Accept() &amp;gt;= 0) { 
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; printf(&amp;quot;Content-type: text/html\r\n&amp;quot; 
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; 	&amp;quot;\r\n&amp;quot; 
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt; 	&amp;quot;&amp;quot; 
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt; 	&amp;quot;FastCGI Hello!&amp;quot; 
&lt;span class=&quot;lineno&quot;&gt;6&lt;/span&gt; 	&amp;quot;Request number %d running on host%s &amp;quot; 
&lt;span class=&quot;lineno&quot;&gt;7&lt;/span&gt; 	&amp;quot;Process ID: %d\n&amp;quot;, ++count, getenv(&amp;quot;SERVER_NAME&amp;quot;), getpid()); 
&lt;span class=&quot;lineno&quot;&gt;8&lt;/span&gt; }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里printf最好换成FCGI_printf，不然当引入stdio头文件的时候会发生错误。&lt;br /&gt;
这里 while (FCGI_Accept() &amp;gt;= 0)表示接受到一个新的请求，然后执行逻辑处理，完成后再回到while循环的开始，阻塞等待下一个请求。如果没有这个while,那就成普通的CGI程序了。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;最后&lt;/h3&gt;
&lt;p&gt;    这样一个小的demo就运行起来了。下篇将整理更深入配置环境的知识，方便之后的开发。&lt;/p&gt;


    </content>
  </entry>
  
  <entry>
    <title>Web开发遇到问题总结</title>
    <link href="/study/Web%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <updated>2015-07-13T00:00:00+08:00</updated>
    <id>/study/Web开发遇到问题汇总</id>
    <author>
      <name>Carson Lin</name>
      <uri>/</uri>
      <email>carsonxiaoyang@gmail.com</email>
    </author>
    <content type="html">
      
      &lt;h3 id=&quot;section&quot;&gt;开头&lt;/h3&gt;
&lt;p&gt;    这里主要是WEB开发中遇到的一些小问题的汇总。&lt;/p&gt;

&lt;h3 id=&quot;javascript&quot;&gt;javascript篇&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;1、使用webuploader时选择按钮死活无效，调了半天才发现是js文件重名了，虽然是放在不同文件目录下。修改其中一个的文件名即可解决。
&lt;/code&gt;&lt;/pre&gt;

    </content>
  </entry>
  
  <entry>
    <title>设计模式学习三</title>
    <link href="/study/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B8%89/"/>
    <updated>2015-07-03T00:00:00+08:00</updated>
    <id>/study/设计模式学习三</id>
    <author>
      <name>Carson Lin</name>
      <uri>/</uri>
      <email>carsonxiaoyang@gmail.com</email>
    </author>
    <content type="html">
      
      &lt;h3 id=&quot;section&quot;&gt;开头&lt;/h3&gt;
&lt;p&gt;    上一章总结了创建型模式的四种，详见&lt;a href=&quot;http://lxyyxl638.github.io/study/设计模式学习二/&quot;&gt;设计模式学习二&lt;/a&gt;。这一章来总结最后一个创建型模式————原型模式(Prototype)。我们还是通过例子来学习。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;例子&lt;/h3&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; //PC
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt; class PC {
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt; 	virtual void addCPU(CPU*) {}//装配CPU
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt; 	virtual void addCard(Card*) {}//装配显卡
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt; //CPU类
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt; class CPU {}
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt; //显卡类
&lt;span class=&quot;lineno&quot;&gt;11&lt;/span&gt; class Card{}
&lt;span class=&quot;lineno&quot;&gt;12&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;13&lt;/span&gt; //Intel工艺的CPU
&lt;span class=&quot;lineno&quot;&gt;14&lt;/span&gt; class IntelCPU : public CPU {
&lt;span class=&quot;lineno&quot;&gt;15&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;16&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;17&lt;/span&gt; //IBM工艺的CPU
&lt;span class=&quot;lineno&quot;&gt;18&lt;/span&gt; class IBMCPU : public CPU {
&lt;span class=&quot;lineno&quot;&gt;19&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;20&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;21&lt;/span&gt; //Intel工艺的显卡
&lt;span class=&quot;lineno&quot;&gt;22&lt;/span&gt; class IntelCard : public Card {
&lt;span class=&quot;lineno&quot;&gt;23&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;24&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;25&lt;/span&gt; //IBM工艺的显卡
&lt;span class=&quot;lineno&quot;&gt;26&lt;/span&gt; class IBMCard : public Card {
&lt;span class=&quot;lineno&quot;&gt;27&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;28&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;29&lt;/span&gt; class factory {
&lt;span class=&quot;lineno&quot;&gt;30&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt;31&lt;/span&gt; 	virtual PC* makePC() {}//返回一台PC
&lt;span class=&quot;lineno&quot;&gt;32&lt;/span&gt; 	virtual CPU* createCPU() {}//生产一个CPU
&lt;span class=&quot;lineno&quot;&gt;33&lt;/span&gt; 	virtual graphics_card* createCard() {}//生产一个显卡
&lt;span class=&quot;lineno&quot;&gt;34&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt;35&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;36&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;37&lt;/span&gt; class PrototypeFactory : public factory{
&lt;span class=&quot;lineno&quot;&gt;38&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt;39&lt;/span&gt; private:
&lt;span class=&quot;lineno&quot;&gt;40&lt;/span&gt; 	CPU* _prototypeCPU;
&lt;span class=&quot;lineno&quot;&gt;41&lt;/span&gt; 	Card* _prototypeCard;
&lt;span class=&quot;lineno&quot;&gt;42&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt;43&lt;/span&gt; public:
&lt;span class=&quot;lineno&quot;&gt;44&lt;/span&gt; 	void PrototypeFactory(CPU* cpu,Card* card) {
&lt;span class=&quot;lineno&quot;&gt;45&lt;/span&gt; 		_prototypeCPU = cpu;//原型
&lt;span class=&quot;lineno&quot;&gt;46&lt;/span&gt; 		_prototypeCard = card;//原型
&lt;span class=&quot;lineno&quot;&gt;47&lt;/span&gt; 	}
&lt;span class=&quot;lineno&quot;&gt;48&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt;49&lt;/span&gt; 	virtual CPU* createCPU() {
&lt;span class=&quot;lineno&quot;&gt;50&lt;/span&gt; 		return _prototypeCPU-&amp;gt;clone();
&lt;span class=&quot;lineno&quot;&gt;51&lt;/span&gt; 	}//生产一个CPU
&lt;span class=&quot;lineno&quot;&gt;52&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt;53&lt;/span&gt; 	virtual graphics_card* createCard() {
&lt;span class=&quot;lineno&quot;&gt;54&lt;/span&gt; 		return _prototypeCard-&amp;gt;clone();
&lt;span class=&quot;lineno&quot;&gt;55&lt;/span&gt; 	}//生产一个显卡
&lt;span class=&quot;lineno&quot;&gt;56&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;57&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;58&lt;/span&gt; //想要自己组装PC的客户
&lt;span class=&quot;lineno&quot;&gt;59&lt;/span&gt; class Client {
&lt;span class=&quot;lineno&quot;&gt;60&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt;61&lt;/span&gt; 	PC* assemblePC(factory* protofactory) {
&lt;span class=&quot;lineno&quot;&gt;62&lt;/span&gt; 		//拿到一个PC实例
&lt;span class=&quot;lineno&quot;&gt;63&lt;/span&gt; 		PC* myPC = protofactory.makePC();
&lt;span class=&quot;lineno&quot;&gt;64&lt;/span&gt; 		CPU* myCPU = protofactory.createCPU();
&lt;span class=&quot;lineno&quot;&gt;65&lt;/span&gt; 		Card* myCard = protofactory.createCard();
&lt;span class=&quot;lineno&quot;&gt;66&lt;/span&gt; 		myPC.addCPU(myPC);
&lt;span class=&quot;lineno&quot;&gt;67&lt;/span&gt; 		myPC.addCard(myCard);
&lt;span class=&quot;lineno&quot;&gt;68&lt;/span&gt; 		return PC
&lt;span class=&quot;lineno&quot;&gt;69&lt;/span&gt; 	}
&lt;span class=&quot;lineno&quot;&gt;70&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt;71&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;72&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;73&lt;/span&gt; int main() {
&lt;span class=&quot;lineno&quot;&gt;74&lt;/span&gt; 	PC* myPC;
&lt;span class=&quot;lineno&quot;&gt;75&lt;/span&gt; 	Client* me = new Client;
&lt;span class=&quot;lineno&quot;&gt;76&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt;77&lt;/span&gt; 	//要一台Intel的CPU,IBM显卡的机器
&lt;span class=&quot;lineno&quot;&gt;78&lt;/span&gt; 	factory* protofactory = new PrototypeFactory(new IntelCPU,new IBMCard);
&lt;span class=&quot;lineno&quot;&gt;79&lt;/span&gt; 	myPC = me.assemblePC(protofactory);
&lt;span class=&quot;lineno&quot;&gt;80&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt;81&lt;/span&gt; 	return 0;
&lt;span class=&quot;lineno&quot;&gt;82&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;83&lt;/span&gt; }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;section-2&quot;&gt;原型模式&lt;/h4&gt;
&lt;p&gt;    原型模式：&lt;code&gt;用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象&lt;/code&gt;。如果我们要配置一台Intel的CPU,IBM的显卡的PC，如果采用抽象工厂的话我们只能再继承abstractory_factory生成一个新类，而使用原型模式，你可以通过构造函数任意搭配。特别是在需要动态加载时候，原型模式的优势就体现出来了。&lt;br /&gt;
    通过将原型传递给PrototypeFactory,它便知道了需要创建对象的种类(什么牌子的CPU，显卡)，然后需要生成对象时便通过原型的拷贝函数返回。当然，拷贝函数必须在IntelCPU类里已经实现。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;与抽象工厂区别&lt;/h4&gt;
&lt;p&gt;    两者之间有可能是竞争关系，但也有可能是合作关系。作为初学者，我只能简单地对比两者。
-	通过上述代码和前面一章的代码，可以看出，原型模式可以获得搭配更灵活的产品（IBM,Intel的部件混合用只需要传入原型不一样就行）。而抽象工厂面对这种情况往往要生成一个新类。
-	原型模式要求部件对象都要实现克隆函数&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;最后&lt;/h4&gt;
&lt;p&gt;    至此5种创建型模式的学习总结就结束了。这仅仅是第一次学习的收获，可能还太浅薄。纸上得来终觉浅，觉知此事要躬行。在以后项目中要有意识地发觉探究里面的设计模式。&lt;/p&gt;


    </content>
  </entry>
  
  <entry>
    <title>设计模式学习二</title>
    <link href="/study/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%BA%8C/"/>
    <updated>2015-06-08T00:00:00+08:00</updated>
    <id>/study/设计模式学习二</id>
    <author>
      <name>Carson Lin</name>
      <uri>/</uri>
      <email>carsonxiaoyang@gmail.com</email>
    </author>
    <content type="html">
      
      &lt;h3 id=&quot;section&quot;&gt;开头&lt;/h3&gt;
&lt;p&gt;    这一章我来总结下对5种创建型设计模式的学习。5种分别是&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;抽象工厂(Abstract Factory)&lt;/li&gt;
  &lt;li&gt;工厂方法(Factory Method)&lt;/li&gt;
  &lt;li&gt;单例模式(Singleton)&lt;/li&gt;
  &lt;li&gt;原型(Prototype)&lt;/li&gt;
  &lt;li&gt;生成器(Builder)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;例子一&lt;/h3&gt;
&lt;p&gt;    定义和概念太难看懂，我们从几个个例子和代码来总结和比较这几种设计模式。&lt;br /&gt;
    我们要组装一台只有CPU和显卡的PC。Intel、IBM都生产CPU、显卡。下面的例子将说明：
-	抽象工厂
-	工厂方法
-	单例模式&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; //PC
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt; class PC {
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt; 	virtual void addCPU(CPU*) {}//装配CPU
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt; 	virtual void addCard(Card*) {}//装配显卡
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt; //CPU类
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt; class CPU {}
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt; //显卡类
&lt;span class=&quot;lineno&quot;&gt;11&lt;/span&gt; class Card{}
&lt;span class=&quot;lineno&quot;&gt;12&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;13&lt;/span&gt; //Intel工艺的CPU
&lt;span class=&quot;lineno&quot;&gt;14&lt;/span&gt; class IntelCPU : public CPU {
&lt;span class=&quot;lineno&quot;&gt;15&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;16&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;17&lt;/span&gt; //IBM工艺的CPU
&lt;span class=&quot;lineno&quot;&gt;18&lt;/span&gt; class IBMCPU : public CPU {
&lt;span class=&quot;lineno&quot;&gt;19&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;20&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;21&lt;/span&gt; //Intel工艺的显卡
&lt;span class=&quot;lineno&quot;&gt;22&lt;/span&gt; class IntelCard : public Card {
&lt;span class=&quot;lineno&quot;&gt;23&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;24&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;25&lt;/span&gt; //IBM工艺的显卡
&lt;span class=&quot;lineno&quot;&gt;26&lt;/span&gt; class IBMCard : public Card {
&lt;span class=&quot;lineno&quot;&gt;27&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;28&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;29&lt;/span&gt; //抽象工厂
&lt;span class=&quot;lineno&quot;&gt;30&lt;/span&gt; class abstract_factory {
&lt;span class=&quot;lineno&quot;&gt;31&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt;32&lt;/span&gt; 	virtual PC* makePC() {}//工厂方法,返回一台PC
&lt;span class=&quot;lineno&quot;&gt;33&lt;/span&gt; 	virtual CPU* createCPU() {}//工厂方法,生产一个CPU
&lt;span class=&quot;lineno&quot;&gt;34&lt;/span&gt; 	virtual graphics_card* createCard() {}//工厂方法,生产一个显卡
&lt;span class=&quot;lineno&quot;&gt;35&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt;36&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;37&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;38&lt;/span&gt; //Intel工厂,不使用单例模式
&lt;span class=&quot;lineno&quot;&gt;39&lt;/span&gt; class Intel : public abstract_factory {
&lt;span class=&quot;lineno&quot;&gt;40&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt;41&lt;/span&gt; 	virtual CPU* createCPU() { return (CPU*) new IntelCPU }//override,生产一个IntelCPU
&lt;span class=&quot;lineno&quot;&gt;42&lt;/span&gt; 	virtual graphics_card* createCard() { return (graphics_card*) new IntelCard}//override,生产一个Intel显卡
&lt;span class=&quot;lineno&quot;&gt;43&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt;44&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;45&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;46&lt;/span&gt; //IBM工厂,使用单例模式
&lt;span class=&quot;lineno&quot;&gt;47&lt;/span&gt; class IBM : public abstract_factory {
&lt;span class=&quot;lineno&quot;&gt;48&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;49&lt;/span&gt; private:
&lt;span class=&quot;lineno&quot;&gt;50&lt;/span&gt; 	static IBM* _instance = 0;//指向实例化对象的指针
&lt;span class=&quot;lineno&quot;&gt;51&lt;/span&gt; protected:
&lt;span class=&quot;lineno&quot;&gt;52&lt;/span&gt; 	IBM(){}//将构造函数设置成protected方法,不能设成private，不然子类就实例化不了了
&lt;span class=&quot;lineno&quot;&gt;53&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt;54&lt;/span&gt; public:
&lt;span class=&quot;lineno&quot;&gt;55&lt;/span&gt; 	//返回一个IBM工厂实例
&lt;span class=&quot;lineno&quot;&gt;56&lt;/span&gt; 	static IBM* getInstance() {
&lt;span class=&quot;lineno&quot;&gt;57&lt;/span&gt; 	  if (0 == _instance) {
&lt;span class=&quot;lineno&quot;&gt;58&lt;/span&gt; 		  _instance = new IBM;
&lt;span class=&quot;lineno&quot;&gt;59&lt;/span&gt; 	  }
&lt;span class=&quot;lineno&quot;&gt;60&lt;/span&gt; 	  return _instance;
&lt;span class=&quot;lineno&quot;&gt;61&lt;/span&gt;    };
&lt;span class=&quot;lineno&quot;&gt;62&lt;/span&gt; 	virtual PC* makePC() {}//返回一台PC
&lt;span class=&quot;lineno&quot;&gt;63&lt;/span&gt; 	virtual CPU* createCPU() { return (CPU*) new IBMCPU }//override,生产一个IBMCPU
&lt;span class=&quot;lineno&quot;&gt;64&lt;/span&gt; 	virtual graphics_card* createCard() { return (graphics_card*) new IBMCard}//override,生产一个IBM显卡
&lt;span class=&quot;lineno&quot;&gt;65&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;66&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;67&lt;/span&gt; //想要自己组装PC的客户
&lt;span class=&quot;lineno&quot;&gt;68&lt;/span&gt; class Client {
&lt;span class=&quot;lineno&quot;&gt;69&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt;70&lt;/span&gt; 	//组装机器，传入一个工厂参数
&lt;span class=&quot;lineno&quot;&gt;71&lt;/span&gt; 	PC* assemblePC(abstract_factory* factory) {
&lt;span class=&quot;lineno&quot;&gt;72&lt;/span&gt; 		//拿到一个PC实例
&lt;span class=&quot;lineno&quot;&gt;73&lt;/span&gt; 		PC* myPC = factory.makePC();
&lt;span class=&quot;lineno&quot;&gt;74&lt;/span&gt; 		CPU* myCPU = factory.createCPU();
&lt;span class=&quot;lineno&quot;&gt;75&lt;/span&gt; 		Card* myCard = factory.createCard();
&lt;span class=&quot;lineno&quot;&gt;76&lt;/span&gt; 		myPC.addCPU(myPC);
&lt;span class=&quot;lineno&quot;&gt;77&lt;/span&gt; 		myPC.addCard(myCard);
&lt;span class=&quot;lineno&quot;&gt;78&lt;/span&gt; 		return PC
&lt;span class=&quot;lineno&quot;&gt;79&lt;/span&gt; 	}
&lt;span class=&quot;lineno&quot;&gt;80&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt;81&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;82&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;83&lt;/span&gt; int main() {
&lt;span class=&quot;lineno&quot;&gt;84&lt;/span&gt; 	Client* me = new Client;
&lt;span class=&quot;lineno&quot;&gt;85&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt;86&lt;/span&gt; 	//没有单例模式的工厂
&lt;span class=&quot;lineno&quot;&gt;87&lt;/span&gt; 	abstract_factory* intel = new Intel;
&lt;span class=&quot;lineno&quot;&gt;88&lt;/span&gt; 	//获得一台intel配置的PC
&lt;span class=&quot;lineno&quot;&gt;89&lt;/span&gt; 	PC* myPC = me.assemblePC(intel);
&lt;span class=&quot;lineno&quot;&gt;90&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt;91&lt;/span&gt; 	或者
&lt;span class=&quot;lineno&quot;&gt;92&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt;93&lt;/span&gt; 	//有单例模式的工厂,不能直接new
&lt;span class=&quot;lineno&quot;&gt;94&lt;/span&gt; 	abstract_factory* IBM = IBM::getInstance();
&lt;span class=&quot;lineno&quot;&gt;95&lt;/span&gt; 	//获得一台IBM配置的PC
&lt;span class=&quot;lineno&quot;&gt;96&lt;/span&gt; 	PC* myPC = me.assemblePC(IBM);
&lt;span class=&quot;lineno&quot;&gt;97&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt;98&lt;/span&gt; 	return 0;
&lt;span class=&quot;lineno&quot;&gt;99&lt;/span&gt; }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;section-2&quot;&gt;抽象工厂：&lt;/h4&gt;
&lt;p&gt;    上面的abstract_factory就是抽象工厂，&lt;code&gt;它提供了一系列相关或者相互依赖的接口，而不用指定他们具体的类&lt;/code&gt;。上面代码中用户只需要往assemblePC传入不同的abstract_factory子类就能得到配置不同的电脑,因为它们的接口都是一样的（createCPU和createCard），抽象工厂生产一个系统的各个部件。所以，抽象工厂一般适用于以下场景：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个系统要由多个产品系列中的一个来配置时（我的PC要么用Intel配置，要么用IBM配置）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;    简而言之，抽象工厂就是在多种系列产品加工厂上再抽象出的一个工厂，方便实现为用户配置提供统一接口。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;工厂方法&lt;/h4&gt;
&lt;p&gt;    上面abstract_factory中的方法（32、33、34行）便是工厂方法，&lt;code&gt;定义一个用于创建对象的接口，让子类决定实例化哪一个类。它使一个类的实例化延迟到子类。&lt;/code&gt;createCPU()创建一个CPU对象，但是Intel还是IBM呢？它只能延迟到它的子类(Intel工厂或者IBM工厂)来实现了，但接口都是一样的。这个还是挺好理解的。&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;单例模式&lt;/h4&gt;
&lt;p&gt;    上面IBM工厂(47行)采用了单例模式，&lt;code&gt;它保证了整个系统中只有一个IBM工厂实例&lt;/code&gt;，直接看代码应该可以明白是如何实现的。这与实际情况也相符合，如果工厂需要统计它生产了多少CPU，那就得用单例模式了。不然用户随便new出很多个Intel工厂的话统计就乱套了。&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;例子二&lt;/h4&gt;
&lt;p&gt;    接下来的例子讲述容易和抽象工厂混淆的生成器模式(Builder),同样针对上面的场景。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;  1&lt;/span&gt; //PC
&lt;span class=&quot;lineno&quot;&gt;  2&lt;/span&gt; class PC {
&lt;span class=&quot;lineno&quot;&gt;  3&lt;/span&gt; 	virtual void addCPU(CPU*) {}//装配CPU
&lt;span class=&quot;lineno&quot;&gt;  4&lt;/span&gt; 	virtual void addCard(Card*) {}//装配显卡
&lt;span class=&quot;lineno&quot;&gt;  5&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;  6&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;  7&lt;/span&gt; //CPU类
&lt;span class=&quot;lineno&quot;&gt;  8&lt;/span&gt; class CPU {}
&lt;span class=&quot;lineno&quot;&gt;  9&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 10&lt;/span&gt; //显卡类
&lt;span class=&quot;lineno&quot;&gt; 11&lt;/span&gt; class Card{}
&lt;span class=&quot;lineno&quot;&gt; 12&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 13&lt;/span&gt; //Intel工艺的CPU
&lt;span class=&quot;lineno&quot;&gt; 14&lt;/span&gt; class IntelCPU : public CPU {
&lt;span class=&quot;lineno&quot;&gt; 15&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt; 16&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 17&lt;/span&gt; //IBM工艺的CPU
&lt;span class=&quot;lineno&quot;&gt; 18&lt;/span&gt; class IBMCPU : public CPU {
&lt;span class=&quot;lineno&quot;&gt; 19&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt; 20&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 21&lt;/span&gt; //Intel工艺的显卡
&lt;span class=&quot;lineno&quot;&gt; 22&lt;/span&gt; class IntelCard : public Card {
&lt;span class=&quot;lineno&quot;&gt; 23&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt; 24&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 25&lt;/span&gt; //IBM工艺的显卡
&lt;span class=&quot;lineno&quot;&gt; 26&lt;/span&gt; class IBMCard : public Card {
&lt;span class=&quot;lineno&quot;&gt; 27&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt; 28&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 29&lt;/span&gt; //生成器，负责生产、组成并返回PC
&lt;span class=&quot;lineno&quot;&gt; 30&lt;/span&gt; class Builder {
&lt;span class=&quot;lineno&quot;&gt; 31&lt;/span&gt; 	//返回一台PC，特别注意这个方法，后文会讲到
&lt;span class=&quot;lineno&quot;&gt; 32&lt;/span&gt; 	virtual PC* getPC() {return 0};
&lt;span class=&quot;lineno&quot;&gt; 33&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt; 34&lt;/span&gt; 	virtual void buildCPU(){}//制作CPU
&lt;span class=&quot;lineno&quot;&gt; 35&lt;/span&gt; 	virtual void buildCard(){}//制作显卡
&lt;span class=&quot;lineno&quot;&gt; 36&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt; 37&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 38&lt;/span&gt; //Intel生成器
&lt;span class=&quot;lineno&quot;&gt; 39&lt;/span&gt; class Intel : public Builder {
&lt;span class=&quot;lineno&quot;&gt; 40&lt;/span&gt; private:
&lt;span class=&quot;lineno&quot;&gt; 41&lt;/span&gt; 	PC* pc;
&lt;span class=&quot;lineno&quot;&gt; 42&lt;/span&gt; 	void assembleCPU(CPU*) {}//组装CPU
&lt;span class=&quot;lineno&quot;&gt; 43&lt;/span&gt; public:
&lt;span class=&quot;lineno&quot;&gt; 44&lt;/span&gt; 	virtual void buildCPU(){
&lt;span class=&quot;lineno&quot;&gt; 45&lt;/span&gt; 		CPU* cpu = createCPU()//伪代码，表示生产了一个CPU，它可以跟上面的抽象工厂一起使用，但这个先忽略
&lt;span class=&quot;lineno&quot;&gt; 46&lt;/span&gt; 		assembleCPU(cpu);//组装CPU
&lt;span class=&quot;lineno&quot;&gt; 47&lt;/span&gt; 	}//制作CPU并组装
&lt;span class=&quot;lineno&quot;&gt; 48&lt;/span&gt; 	virtual void buildCard(){}//制作显卡
&lt;span class=&quot;lineno&quot;&gt; 49&lt;/span&gt; 	//返回一个PC
&lt;span class=&quot;lineno&quot;&gt; 50&lt;/span&gt; 	virtual PC* getPC() {return pc};
&lt;span class=&quot;lineno&quot;&gt; 51&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt; 52&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 53&lt;/span&gt; //想要自己组装PC的客户A
&lt;span class=&quot;lineno&quot;&gt; 54&lt;/span&gt; class ClientA {
&lt;span class=&quot;lineno&quot;&gt; 55&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt; 56&lt;/span&gt; 	//组装机器，传入一个生成器参数
&lt;span class=&quot;lineno&quot;&gt; 57&lt;/span&gt; 	PC* assemblePC(Builder* builder) {
&lt;span class=&quot;lineno&quot;&gt; 58&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt; 59&lt;/span&gt; 		//只装一个CPU
&lt;span class=&quot;lineno&quot;&gt; 60&lt;/span&gt; 		builder.buildCPU();
&lt;span class=&quot;lineno&quot;&gt; 61&lt;/span&gt; 		
&lt;span class=&quot;lineno&quot;&gt; 62&lt;/span&gt; 		//装一个显卡
&lt;span class=&quot;lineno&quot;&gt; 63&lt;/span&gt; 		builder.buildCard();
&lt;span class=&quot;lineno&quot;&gt; 64&lt;/span&gt; 		
&lt;span class=&quot;lineno&quot;&gt; 65&lt;/span&gt; 		//获得PC
&lt;span class=&quot;lineno&quot;&gt; 66&lt;/span&gt; 		return builder.getPC();
&lt;span class=&quot;lineno&quot;&gt; 67&lt;/span&gt; 	}
&lt;span class=&quot;lineno&quot;&gt; 68&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt; 69&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt; 70&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 71&lt;/span&gt; //想要自己组装PC的客户B
&lt;span class=&quot;lineno&quot;&gt; 72&lt;/span&gt; class ClientB {
&lt;span class=&quot;lineno&quot;&gt; 73&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt; 74&lt;/span&gt; 	//组装机器，传入一个生成器参数
&lt;span class=&quot;lineno&quot;&gt; 75&lt;/span&gt; 	PC* assemblePC(Builder* builder) {
&lt;span class=&quot;lineno&quot;&gt; 76&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt; 77&lt;/span&gt; 		//一口气装了3个CPU
&lt;span class=&quot;lineno&quot;&gt; 78&lt;/span&gt; 		builder.buildCPU();
&lt;span class=&quot;lineno&quot;&gt; 79&lt;/span&gt; 		builder.buildCPU();
&lt;span class=&quot;lineno&quot;&gt; 80&lt;/span&gt; 		builder.buildCPU();
&lt;span class=&quot;lineno&quot;&gt; 81&lt;/span&gt; 		
&lt;span class=&quot;lineno&quot;&gt; 82&lt;/span&gt; 		//装一个显卡
&lt;span class=&quot;lineno&quot;&gt; 83&lt;/span&gt; 		builder.buildCard();
&lt;span class=&quot;lineno&quot;&gt; 84&lt;/span&gt; 		
&lt;span class=&quot;lineno&quot;&gt; 85&lt;/span&gt; 		//获得PC
&lt;span class=&quot;lineno&quot;&gt; 86&lt;/span&gt; 		return builder.getPC();
&lt;span class=&quot;lineno&quot;&gt; 87&lt;/span&gt; 	}
&lt;span class=&quot;lineno&quot;&gt; 88&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt; 89&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt; 90&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 91&lt;/span&gt; //用户开始使用
&lt;span class=&quot;lineno&quot;&gt; 92&lt;/span&gt; int main() {
&lt;span class=&quot;lineno&quot;&gt; 93&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 94&lt;/span&gt; 	PC* myPC;
&lt;span class=&quot;lineno&quot;&gt; 95&lt;/span&gt; 	Builder* IntelBuilder = new Intel;
&lt;span class=&quot;lineno&quot;&gt; 96&lt;/span&gt; 	ClientA* me = new ClientA
&lt;span class=&quot;lineno&quot;&gt; 97&lt;/span&gt; 	PC = me.assemblePC(IntelBuilder);
&lt;span class=&quot;lineno&quot;&gt; 98&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt; 99&lt;/span&gt; 	return 0;
&lt;span class=&quot;lineno&quot;&gt;100&lt;/span&gt; }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;section-6&quot;&gt;生成器模式&lt;/h4&gt;
&lt;p&gt;    生成器模式定义：&lt;code&gt;将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示&lt;/code&gt;。上面代码乍一看跟抽象工厂差不多，只是把factory换成了builder。但其实本质是不一样的。在生成器模式下有三种角色:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Product(PC)：需要构造的复杂对象&lt;/li&gt;
  &lt;li&gt;Builder(生产和实现装配的Intel,IBM)：为创建Product各个部件指定抽象接口。&lt;/li&gt;
  &lt;li&gt;Director(Client,负责控制装机流程的)：构造一个使用Builder接口的对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;    跟抽象工厂对比：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ClientA和ClientB是看不到CPU,Card这两个部件的。它只能调用builder去装机，但装的具体细节全由builder（Intel）控制，用户(Director)完全不知道，director只能控制装机流程（要装几个CPU，几个显卡）。&lt;/li&gt;
  &lt;li&gt;抽象工厂一开始就获得了构建对象(PC)，而生成器模式是一步一步装载PC，最后才返回给用户PC。这个从时间点上不一样。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;    再回过头去看生成器的定义，构建(CPU的生产和装载具体做法全都封装在了Builder里)和表示(Director通过不同的实现制造出不同的Product)分离。同样的构建过程(同一个builder)可以创建不同表示(3个CPU的PC还是1个CPU的PC)。&lt;/p&gt;

&lt;h4 id=&quot;section-7&quot;&gt;生成器模式和抽象工厂的对比&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;两者都能构建复杂对象。但抽象工厂着重于构建相同系列的部件供给用户使用，用户爱怎么倒腾不关它的事（有用户喜欢把CPU插在内存插槽上或者其他奇奇怪怪的操作），而生成器着重于构建一个产品，它将产品具体装配封装起来，用户只能控制装载流程，但不能控制具体操作(你不能把CPU插在内存上，你只能决定需要几个CPU)。&lt;/li&gt;
  &lt;li&gt;根据上一条和代码，可以看出，抽象工厂是立马将产品生成，而生成器是到最后一步才把产品生成。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-8&quot;&gt;最后&lt;/h4&gt;
&lt;p&gt;撑不住，睡觉了…原型模式下次再总结…&lt;/p&gt;

    </content>
  </entry>
  
  <entry>
    <title>设计模式学习一</title>
    <link href="/study/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B8%80/"/>
    <updated>2015-06-01T00:00:00+08:00</updated>
    <id>/study/设计模式学习一</id>
    <author>
      <name>Carson Lin</name>
      <uri>/</uri>
      <email>carsonxiaoyang@gmail.com</email>
    </author>
    <content type="html">
      
      &lt;p&gt;    最近实习面试几乎场场都会问到设计模式，之前虽然也有用到过，但没有系统地学习过，借此机会补下课。本文仅是基于一个初学小白理解的总结，可能有些漏洞，欢迎纠错。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section&quot;&gt;设计模式分类：&lt;/h3&gt;
&lt;p&gt;常见设计模式有23种，分别为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;创建型：5种&lt;/li&gt;
  &lt;li&gt;结构型：7种&lt;/li&gt;
  &lt;li&gt;行为型：11种&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;创建型模式&lt;/h3&gt;

&lt;p&gt;    创建型模式，按照《设计模式》一书中的说明:&lt;br /&gt;&lt;/p&gt;
&lt;pre&gt;
	&lt;code&gt;
	创建型模式抽象了实例化过程，他们帮助一个系统独立于如何创建、组合和表示它的那些对象。
	一个类创建型模式使用继承改变被实例化的类，而一个对象创建型模式将实例化委托给另一个对象。
	&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;    一开始看这段话的时候没怎么懂，通过形象的例子之后才明白。这里引用书上的例子。你玩一个走迷宫游戏，这里的迷宫游戏就是上面所说的&lt;code&gt;系统&lt;/code&gt;，你可以用createMaze()函数配置这个游戏的场景（实现创建墙壁，门，出入口等操作），有&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;普通迷宫&lt;/li&gt;
  &lt;li&gt;魔法型迷宫（墙壁有魔法效果）&lt;/li&gt;
  &lt;li&gt;HelloKitty主题迷宫&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;    最直接的做法就是在createMaze()里硬编码，这样每次要更换场景的时候就不得不重新更改代码。如果我们能在上面三个迷宫类型上面再抽象出一个类Abstract Maze,就能通过多态将代表三个迷宫场景的子类通过Abstract Maze传递给createMaze()。这样根本不需要改变createMaze()的代码就能实现三种模式的转换。这个就是创建型模式，抽象了实例化过程（迷宫场景的生成），系统独立于对象的创建，组合（创建迷宫的使用者不需要知道对象的具体实现，它只需要接收一个抽象类参数并调用接口就行了），在后文会说明这Abstract Maze其实就是抽象工厂，而createMaze()就是工厂方法。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;结构性模式&lt;/h3&gt;
&lt;p&gt;    顾名思义，结构性模式就是负责组合类和对象，目的是获得更大的结构。结构性类模式采用继承机制来组合接口和实现。根据《设计模式》一书中所说，最简单的例子就是采用多重继承使得子类获得所有父类的性质。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;行为模式&lt;/h3&gt;
&lt;p&gt;    行为模式涉及到算法和对象间职责的分配。行为模式不仅描述对象或类的模式，还描述他们之间的通信模式。这些模式刻划了在运行时难以跟踪的控制流。他们将你的注意力从控制流转移到对象间的联系方式上。—《设计模式》&lt;br /&gt;
    行为类模式采用类继承机制实现在类间分配任务，行为对象通过对象复合以实现更高级的行为。一言以蔽之，行为模式是为了实现更复杂的算法或行为。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;最后&lt;/h3&gt;
&lt;p&gt;    本文仅仅是对三大类设计模式进行了一次梗概，具体每种设计模式是什么样的将在后续的学习中一一阐述。&lt;/p&gt;

    </content>
  </entry>
  
  <entry>
    <title>依图面试总结</title>
    <link href="/study/%E4%BE%9D%E5%9B%BE%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <updated>2015-05-27T00:00:00+08:00</updated>
    <id>/study/依图面试总结</id>
    <author>
      <name>Carson Lin</name>
      <uri>/</uri>
      <email>carsonxiaoyang@gmail.com</email>
    </author>
    <content type="html">
      
      &lt;h3 id=&quot;section&quot;&gt;一面：&lt;/h3&gt;
&lt;p&gt;    1、LeetCode原题，判断一个数是不是2的幂。&lt;br /&gt;
    当时没想起来是LeetCode原题，直观地利用二进制表示是否只有一个1的做法，因为如果是2的幂的话二进制表示肯定只有一个1，这样做法是O(32)的。后来面试官问有什么可以优化的，我没直接想出来，但给出了思考方向。先是试探性地问面试官他现在是希望我想出一个一步到位的算法，得到肯定回答后可以排除一些奇怪的想法，那么只剩下两种可能性。一种是一步算出有多少个1，另一种是消掉其中一个1然后看是否还有1。显然第一种是走不通的，那么只省下第二种可能性，面试官表示了赞同。在经过这样一番沟通后，面试官提示我可以考虑下和x-1的关系，这个时候我才想起这事leetCode原题，但时间太久还是没想起来，现场试验后发现这就是消掉最右边一个1的做法。&lt;br /&gt;
    2、下围棋的情况判断&lt;br /&gt;
    面试官拿了一张纸画了一个围棋盘，然后用黑白磁铁当做棋子摆出个棋局。是围棋规则，要让对手没一口活棋（就是他落哪都不能围住我但自己会被围）。然后又画了一个空格，两个空格，三个空格，四个空格及其以上的情况，其实问题的关键是黑棋只要能构建出两个独立的联通分量的话他就能活（不被围死）。但当时对规则理解实在没咋懂，加上中午没睡觉所以有点懵，没找出关键。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;二面：&lt;/h3&gt;
&lt;p&gt;    1、给一个三维坐标A，找另一个高低位相同的三维坐标，使得离A最近。&lt;br /&gt;
    根据距离公式可以得出三个分量独立，然后每个分量只需要16次枚举就行。当时没想到按最直接的想法想就行，想偏了。在提示下才做出来的。接下来是写代码，这题涉及到字符串和整型的互相转化，写了四个函数。写得比较慢，但好险没出bug，弥补了前面的失误。&lt;br /&gt;
    2、LeetCode原题，给一个字符串，找出最长子串使得其实没一个字符重复&lt;br /&gt;
    LeetCode原题，直接用个数组标记就行，但实在很困，语言表达得很渣。这题没写代码。&lt;br /&gt;
    3、给一个整型数组，找出能整除p的子数组的个数。&lt;br /&gt;
    一开始想复杂了，甚至往动态规划上想去了，其实也是从最直接的做法优化。O（N^2）枚举所有情况，用前缀和(sum[j] - sum[i]) mod p判断，代入问题转换成将前缀和mod p之后看有多少对相同的。这个用个统排计算一下即可，当时漏了一种情况就是sum[i] mod p == 0时要单独加上（长度为1的也符合条件）。这个代码也比较好实现。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;    被突然问了数分成绩，可能是因为第三题看出了这个数学基础不扎实… &lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-3&quot;&gt;三面:&lt;/h3&gt;
&lt;p&gt;    1、写最短路&lt;br /&gt;
    写了个最好写的floyed..&lt;br /&gt;
    2、证明最短路
    写了之后发现自己把自己坑了，竟然要求证明…实在不知道从何下手，在面试官提醒下才加了一维F[i][j][k]用动态规划的方法写出了转移方程。最后问了一个为什么第三维可以省略，这个实在不知道怎么表达，最后他跟我说只需要答在第k次计算时f[i][j]的值还是表示k-1，即没有被更新过即可。&lt;br /&gt;
    3、LeetCode原题，ZigZag打印&lt;br /&gt;
    LeetCode原题，方阵打印。先枚举对角线x + y的和，在逐个遍历即可。当时脑子不清醒用了m,n两个变量变成不是方阵了。&lt;br /&gt;
    4、介绍项目&lt;br /&gt;
    就简单地介绍了下传承，还是被问到了老问题，遇到的最大困难是什么。我答了一是项目协同工作以及我们怎么克服，二是资料审查，当前只能人工，后期打算通过用户筛选。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;    被面试官问了句“数学是不是没学好”…竟然被发现了…&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-5&quot;&gt;四面：&lt;/h3&gt;
&lt;p&gt;    1、两个排好序的数组，求交集&lt;br /&gt;
    用两个光标分别扫描A,B数组，如果A[i] == B[j]，那么就是目标交集，i++,j++。否则，加那个比较小的。这样是O(N)的&lt;br /&gt;
    2、如果一个数组很大，有100w，另外一个很小,只有10&lt;br /&gt;
    扫描小的，然后二分大的，这样是O(nLogM)&lt;br /&gt;
    3、考虑一个1T的文本数据存储，硬盘7200转，I/O 100MB/s，内存16GB，带宽10GB。输入一个数，判断是否存在于文本中。问1s可以满足多少次访问&lt;br /&gt;
    给跪了，磁盘访问这个完全不会，现场教的，要用B+树思想，其实就是建立索引，16GB的索引，然后再读入索引对应的序列。在这样之上读入对应序列的时间几乎可以忽略不计，即没有用到100MB/s那么大的I/O，因此可以减少索引大小，让我算减少多少。我就列方程解，不知道为什么死活解不出来…可能饿得困得头昏眼花了…最后好险面试官放过我了。说我这种算法是学生思维，真正在工程里这是最简单的问题，你需要知道这个东西真正的瓶颈在哪里。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;    边吃饭边面的，脑子已经混了。加上身边很吵，根本不知道自己在想什么，感觉完全跪了。但可能是因为基础的算法想得比较快，而且主动拿出纸笔写代码。（想不出不敢吃饭呀….）最后还是让过了。&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;总结：&lt;/h2&gt;
&lt;p&gt;    总的来说这次没有什么压力，所以面得比较轻松，但是一轮轮车轮战体力脑子实在是个问题。最后都感觉眼前一片模糊了，不过好险坚持了下来。这或许有压力测试的成分吧，所以坚决不放弃还是很有用的。&lt;/p&gt;

    </content>
  </entry>
  
  
</feed>