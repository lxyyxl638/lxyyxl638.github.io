<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title>Carson的博客</title>
  <generator uri="https://github.com/jekyll/jekyll">Jekyll v2.4.0</generator>
    <icon>/apple-touch-icon-precomposed.png</icon>
  <subtitle>My Life</subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="/" rel="alternate" type="text/html"/>
  <updated>2015-08-22T18:50:27+08:00</updated>
  <id>/</id>
  <author>
    <name>Carson Lin</name>
    <uri>/</uri>
    <email>carsonxiaoyang@gmail.com</email>
  </author>

  
  <entry>
    <title>UNIX环境高级编程学习笔记三</title>
    <link href="/study/unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%B8%89/"/>
    <updated>2015-08-22T00:00:00+08:00</updated>
    <id>/study/unix环境高级编程学习三</id>
    <author>
      <name>Carson Lin</name>
      <uri>/</uri>
      <email>carsonxiaoyang@gmail.com</email>
    </author>
    <content type="html">
      
      &lt;h3 id=&quot;section&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;        这一次学习文件I/O，属于不带缓冲的I/O，每个read/write都调用内核中的一个系统调用。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;文件描述符&lt;/h3&gt;
&lt;p&gt;        正如第一章所说，文件描述符作为进程打开的文件的一个标志&lt;br /&gt;
&lt;code&gt;STDIN_FILENO&lt;/code&gt;,&lt;code&gt;STDOUT_FILENO&lt;/code&gt;和&lt;code&gt;STDERR_FILENO&lt;/code&gt;是标准输入，标准输出和标准错误的文件描述符，对应幻数0、1、2&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;打开文件&lt;/h3&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; int open (const char *__file, int __oflag, ...)
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; int openat (int __fd, const char *__file, int __oflag, ...)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;        两者打开的文件描述符一定是最小描述符&lt;br /&gt;
open函数是最基本的打开文件函数，__oflag指定打开文件的选项，有只读，只写，追加等等，O_SYNC可以阻塞到物理I/O完成再返回。
openat是新增函数，一是让线程可以使用相对路径名打开目录中的文件，而不再只能打开当前工作目录，二是避免TOCTTOUT错误&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;关闭文件&lt;/h3&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; int close(int fd)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;        关闭文件描述符对应的文件，进程终止时，内核自动关闭它打开的所有文件&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;文件偏移量&lt;/h3&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; off_t lseek(int fd, off_t offset,int whence)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;        lseek()。当文件描述符指向管道、FIFO或者网络套接字时返回-1。有些文件系统支持负数偏移量，所以要测试返回值是否等于-1而不仅仅是负数。&lt;br /&gt;
        当追求的偏移量大于文件末尾，在新内容与之前内容末尾有一段“空洞”，空洞不会算进长度但会占用磁盘块，内容全以0填充&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;读文件&lt;/h3&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; ssize_t read(int fd, void *buf,size_t nbytes);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;section-6&quot;&gt;写数据&lt;/h3&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; ssize_t write(int fd, const void *buf,size_t nbytes);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;io&quot;&gt;I/O效率&lt;/h3&gt;
&lt;p&gt;在磁盘块长度为4096字节情况下，缓冲区设置为4096以上性能最好&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;文件共享&lt;/h3&gt;
&lt;p&gt;        要理解文件共享，参照下面一幅图&lt;/p&gt;
&lt;figure&gt;
	&lt;a href=&quot;../../images/8-22-1.png&quot;&gt;&lt;img src=&quot;../../images/8-22-1.png&quot; width=&quot;600px&quot; /&gt;&lt;/a&gt;
&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;每一个进程会维护一个进程表项（列表），每一项包含一个&lt;code&gt;文件描述符标志&lt;/code&gt;和一个&lt;code&gt;指向一个文件表项的指针&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;内核为所有打开文件维持一张文件表。包含&lt;code&gt;文件状态标志（读、写、添写等）&lt;/code&gt;，&lt;code&gt;文件偏移量&lt;/code&gt;和&lt;code&gt;指向文件节点表项的指针（指向真正文件节点的指针）&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;figure&gt;
	&lt;a href=&quot;../../images/8-22-2.png&quot;&gt;&lt;img src=&quot;../../images/8-22-2.png&quot; width=&quot;600px&quot; /&gt;&lt;/a&gt;
&lt;/figure&gt;

&lt;p&gt;        这样每个进程对同一个文件的偏移量和操作都是不一样的。当对同一个文件写的时候就会出现问题。A、B进程对同一个文件的偏移量不同，在写的时候会出现覆盖掉前面进程写的数据的情况，即使每一次都先调用lseek将偏移量定位到末尾也会。比如,A、B都调用lseek然后write。那可能在A write之前B调用了lseek，那么B就会覆盖了A的write数据，这是因为这些都不是原子操作。&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;原子操作&lt;/h3&gt;
&lt;p&gt;        打开文件的时候将文件状态标志设置成O_APPEND，这样每次调用write的时候内核会先将偏移量定位到末尾然后再write,将两步合成一步。这也是和lseek后再write的不同。&lt;/p&gt;

&lt;h3 id=&quot;dupdup2&quot;&gt;dup和dup2&lt;/h3&gt;
&lt;p&gt;        dup和dup2是复制一个文件描述符，共享一个文件表项，如下图&lt;/p&gt;

&lt;figure&gt;
	&lt;a href=&quot;../../images/8-22-3.png&quot;&gt;&lt;img src=&quot;../../images/8-22-3.png&quot; width=&quot;500px&quot; /&gt;&lt;/a&gt;
&lt;/figure&gt;

&lt;h3 id=&quot;syncfsyncfdatasync&quot;&gt;sync、fsync、fdatasync&lt;/h3&gt;
&lt;p&gt;        我们向文件写数据时，内核会先将数据复制到缓冲区，然后排入队列。然后再写入磁盘，即&lt;code&gt;延迟写&lt;/code&gt;。&lt;br /&gt;
        而利用这三个函数可以修改这个过程。
-	sync将所有修改过的块缓冲区排入写队列，通常update系统守护进程会定期执行
-	fsync对一个fd起作用，会等到磁盘操作结束才返回，会更新文件属性
-	fdatasync和fsync类似，但只影响数据部分&lt;/p&gt;

&lt;h3 id=&quot;fcntl&quot;&gt;fcntl&lt;/h3&gt;
&lt;p&gt;        fcnl函数可以改变已经打开文件的属性&lt;/p&gt;

&lt;h3 id=&quot;ioctldevfd&quot;&gt;ioctl和/dev/fd&lt;/h3&gt;
&lt;p&gt;        这两部分没怎么懂&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;最后&lt;/h3&gt;
&lt;p&gt;        这一章重点是要理解文件描述符的结构，理解原子操作。&lt;/p&gt;

    </content>
  </entry>
  
  <entry>
    <title>UNIX环境高级编程学习笔记二</title>
    <link href="/study/unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%BA%8C/"/>
    <updated>2015-08-21T00:00:00+08:00</updated>
    <id>/study/unix环境高级编程学习二</id>
    <author>
      <name>Carson Lin</name>
      <uri>/</uri>
      <email>carsonxiaoyang@gmail.com</email>
    </author>
    <content type="html">
      
      &lt;h3 id=&quot;section&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;        第二章&lt;code&gt;UNIX标准化及实现&lt;/code&gt;的学习笔记&lt;/p&gt;

&lt;h3 id=&quot;unix&quot;&gt;UNIX标准化&lt;/h3&gt;
&lt;p&gt;        由于Unix的盛行，制定标准是必须的事情，不然就不同厂商做的都不一样，程序的移植性就非常的差。从而有了以下三个标准：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ISO C&lt;/li&gt;
  &lt;li&gt;IEEE POSIX&lt;/li&gt;
  &lt;li&gt;Single UNIX Specification&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;    三个标准，是接口的规范，厂商根据接口规范编程具体实现&lt;/p&gt;

&lt;h3 id=&quot;unix-1&quot;&gt;UNIX系统实现&lt;/h3&gt;
&lt;p&gt;        有了标准，厂商就得根据标准做具体的实现，于是有了三个分支&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;AT&amp;amp;T分支(UNIX的商用版本)&lt;/li&gt;
  &lt;li&gt;加州大学伯克利分校分支&lt;/li&gt;
  &lt;li&gt;AT&amp;amp;T不断开发的UNIX研究版本&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;        三个分支对应了以下的版本&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SVR4(UNIX System V Release 4)&lt;/li&gt;
  &lt;li&gt;4.4BSD(Berkeley Software Distribution)&lt;/li&gt;
  &lt;li&gt;FreeBSD&lt;/li&gt;
  &lt;li&gt;Linux&lt;/li&gt;
  &lt;li&gt;Mac OS X,核心是Darwin，是一种Unix-like操作系统&lt;/li&gt;
  &lt;li&gt;Solaris，基于SVR4	&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;        这几种都不同程度上符合POSIX标准。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;限制&lt;/h3&gt;
&lt;p&gt;        为了软件移植性（比如不同系统允许打开的文件描述符最大值不同），必须在以下两方面提供限制&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;编译时限制（短整型的最大值是多少）&lt;/li&gt;
  &lt;li&gt;运行时限制（文件名有多少字符）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;        编译时限制在头文件中定义，运行时限制要求进程调用一个函数获得限制值。&lt;br /&gt;
        比如文件名可以有多少字符取决于文件系统，因此只能在运行时调用函数获取该系统的长度限制。为了可移植性不能写在头文件里。&lt;br /&gt;
        下面3种限制是为了解决这个问题&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;头文件（编译时限制）&lt;/li&gt;
  &lt;li&gt;与文件或目录无关的运行时限制(sysconf函数)&lt;/li&gt;
  &lt;li&gt;与文件或目录有关的运行时限制(pathconf和fpathconf函数)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;        相应的各个标准的限制如下&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ISO C限制
    编译时限制都在&lt;limits.h&gt;中，定义了各种类型的上下限&lt;/limits.h&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;POSIX&lt;/li&gt;
  &lt;li&gt;XSI限制&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;sysconfpathconffpathconf&quot;&gt;sysconf,pathconf,fpathconf&lt;/h4&gt;
&lt;p&gt;        这三个函数定义了运行时限制，比如同个系统但使用了不同文件系统导致的不同。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;基本系统数据类型&lt;/h3&gt;
&lt;p&gt;        &amp;lt;sys/types.h&amp;gt;定义了clock_t等基本系统数据类型&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;标准间冲突&lt;/h3&gt;
&lt;p&gt;        有冲突时，POSIX服从ISO标准。&lt;/p&gt;

    </content>
  </entry>
  
  <entry>
    <title>UNIX环境高级编程学习笔记一</title>
    <link href="/study/unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%B8%80/"/>
    <updated>2015-08-19T00:00:00+08:00</updated>
    <id>/study/unix环境高级编程学习一</id>
    <author>
      <name>Carson Lin</name>
      <uri>/</uri>
      <email>carsonxiaoyang@gmail.com</email>
    </author>
    <content type="html">
      
      &lt;h3 id=&quot;section&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;        这阵子得系统地学习下unix编程，学习的资料便是大名鼎鼎的W.Richard Stevens的《Unix环境高级编程》。要坚持写下学习笔记。这一篇主要是对Unix一些基本概念和术语有个大概系统的了解。&lt;/p&gt;

&lt;h3 id=&quot;unix&quot;&gt;unix体系结构&lt;/h3&gt;
&lt;p&gt;        学习Unix编程的第一步当然是要对Unix的体系结构有个了解。特别是&lt;code&gt;“内核”&lt;/code&gt;这个东西。Unix内核是一种操作系统，控制着计算机系统资源，提供程序运行环境，提供了和硬件交互的基本接口——系统调用，用户可以通过系统调用来与硬件进行交互，比如读写内存。&lt;br /&gt;
        公用函数库是对系统调用进行了多一层的封装。Shell是一个程序，可以使用户通过命令行方便地与内核进行交互。&lt;br /&gt;
        而我们一般用户使用的应用程序便是最外面一层，通过调用公用函数库或者直接调用系统调用来实现功能，比如写文件等等。&lt;br /&gt;
        参照以下图片&lt;br /&gt;&lt;/p&gt;

&lt;figure&gt;
	&lt;a href=&quot;../../images/8-19-1.png&quot;&gt;&lt;img src=&quot;../../images/8-19-1.png&quot; width=&quot;250px&quot; /&gt;&lt;/a&gt;
&lt;/figure&gt;
&lt;p&gt;        &lt;br /&gt;可以简单地理解成这是一个逐层封装简化操作接口的过程。但本质都是不变的，比如你可以通过记事本（应用程序）写文件，也可以直接在shell写文件。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;口令文件&lt;/h3&gt;
&lt;p&gt;        一般在/etc/passwd，存放着用户的信息，比如用户ID，登录名，密码什么的。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;输入输出&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;文件描述符&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;        顾名思义，&lt;code&gt;文件描述符&lt;/code&gt;就是描述一个进程打开的文件。这样读写文件就可以用&lt;code&gt;文件描述符&lt;/code&gt;进行操作&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;标准输入，标准输出，标准错误&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;        这三个分别对应着三种文件描述符，都指向终端。每一个新程序运行，这三个文件描述符都会打开&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;不带缓冲的I/O&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;        read,write,open,close,lseek，在&lt;unistd.h&gt;里&lt;/unistd.h&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;带缓冲的I/O&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;        就是标准I/O函数，如printf,getc，在&lt;stdio.h&gt;里&lt;/stdio.h&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;进程和程序&lt;/h3&gt;
&lt;p&gt;        进程就是一个被加载到内存的程序的活体，拥有地址空间，堆栈等资源。Unix每启动一个进程其实就是内核调用exec函数生出的init进程（进程号为1）的子进程。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;出错处理&lt;/h3&gt;
&lt;p&gt;        errno为整型，在&lt;errno.h&gt;中。当Unix函数出错它便会被设置成一个值，但注意
-	不出错不会清除，仅当出错的时候才会重写
-	永远不会为0&lt;/errno.h&gt;&lt;/p&gt;

&lt;p&gt;        C标准里定义了两个函数，帮助打印出错信息。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; char* strerror(int errnum)
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; 将errnum输出成对应的一条字符串。
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; void perror(const char *msg)
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt; 同理&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;出错恢复&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;        &lt;errno.h&gt;中将出错分成致命性和非致命性的。致命性的只能输出错误信息然后终止，非致命性的还不至于要终止进程。&lt;/errno.h&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;用户标识&lt;/h3&gt;
&lt;p&gt;        Unix中用户使用&lt;code&gt;用户id&lt;/code&gt;进程标识，用户还可以有附属属性&lt;code&gt;组id&lt;/code&gt;。这样方便用户管理。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;信号&lt;/h3&gt;
&lt;p&gt;        信号用来通知进程已发生某种情况。
        信号处理方式：
-	忽略信号
-	按系统默认方式处理
-	捕捉信号，用自编函数处理&lt;/p&gt;

&lt;p&gt;        比如&lt;code&gt;中断键&lt;/code&gt;，&lt;code&gt;退出键&lt;/code&gt;，&lt;code&gt;kill&lt;/code&gt;都会向对应进程发送信号。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;时间值&lt;/h3&gt;
&lt;p&gt;        Unix里用两个变量来表示时间&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;日历时间time_t&lt;/li&gt;
  &lt;li&gt;进程时间clock_t&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;        这里有四个时间的定义&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;时钟时间=墙上始终时间，进程运行时间总量&lt;/li&gt;
  &lt;li&gt;用户CPU时间=执行用户指令所用时间&lt;/li&gt;
  &lt;li&gt;系统CPU时间=执行内核程序所用时间&lt;/li&gt;
  &lt;li&gt;CPU时间=用户CPU时间+系统CPU时间&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-8&quot;&gt;系统调用和库函数&lt;/h3&gt;
&lt;p&gt;        如下图。系统调用提供了内核与用户进程交互的接口，库函数是在系统调用函数上又封装了一层。用户的应用代码可以调用库函数也可以直接调用系统调用函数。如malloc是库函数，但本质上是调用了sbrk这个系统调用函数。&lt;/p&gt;

&lt;figure&gt;
	&lt;a href=&quot;../../images/8-19-1.png&quot;&gt;&lt;img src=&quot;../../images/8-19-2.png&quot; width=&quot;600px&quot; /&gt;&lt;/a&gt;
&lt;/figure&gt;

&lt;h3 id=&quot;section-9&quot;&gt;最后&lt;/h3&gt;
&lt;p&gt;        本章简单地总结了我对《Unix环境高级编程》第一章的简单理解。接下来会逐章深入学习&lt;/p&gt;

    </content>
  </entry>
  
  <entry>
    <title>高可用聊天室构建实习故事III Google Ctemplate</title>
    <link href="/study/Google%20Ctemplate/"/>
    <updated>2015-07-27T00:00:00+08:00</updated>
    <id>/study/Google Ctemplate</id>
    <author>
      <name>Carson Lin</name>
      <uri>/</uri>
      <email>carsonxiaoyang@gmail.com</email>
    </author>
    <content type="html">
      
      &lt;h3 id=&quot;section&quot;&gt;前言：&lt;/h3&gt;
&lt;p&gt;        由于采用没有采用任何框架，所以很多工具都得自己造或者用第三方库拼拼凑凑。这一章来讲述一下使用C++模板引擎Google Ctemplate搭建自己简易的MVC框架。&lt;br /&gt;
        使用模板引擎的目的是为了将数据和样式分离开。这样就不用生硬地将数据嵌在样式代码里了。&lt;br /&gt;
        回忆下我们第一章的CGI程序demo，我们需要将整个HTML文件按标准输出的格式输出。&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; while (FCGI_Accept() &amp;gt;= 0) { 
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; printf(&amp;quot;Content-type: text/html\r\n&amp;quot; 
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; 	&amp;quot;\r\n&amp;quot; 
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt; 	&amp;quot;&amp;quot; 
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt; 	&amp;quot;FastCGI Hello!&amp;quot; 
&lt;span class=&quot;lineno&quot;&gt;6&lt;/span&gt; 	&amp;quot;Request number %d running on host%s &amp;quot; 
&lt;span class=&quot;lineno&quot;&gt;7&lt;/span&gt; 	&amp;quot;Process ID: %d\n&amp;quot;, ++count, getenv(&amp;quot;SERVER_NAME&amp;quot;), getpid()); 
&lt;span class=&quot;lineno&quot;&gt;8&lt;/span&gt; }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;        这里有两个变量，count和getpid()。如果不将数据和样式分离，当有几十个变量的时候这个printf函数就会很长很难看，而且无法像一个简单的html页面一样可以很方便地调试。&lt;br /&gt;
        Ctemplate网上找不到中文文档，但是因为其本身自带的文档已经写得很详细，所以本章仅对重要部分按照我的理解进行阐述，并列举几个比较重要的部分。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;梗概&lt;/h3&gt;
&lt;p&gt;        让我们先对Ctemplate有一个感性的了解。它由两部分组成:&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;模板（Templates）&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据字典(Data Dictionaries)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;模板&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; 	&lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; 	 	&lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;{{TITLE}}&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;{{META_TAGS}}
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt; 	&lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt;    &lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;6&lt;/span&gt;    		{{BODY}}
&lt;span class=&quot;lineno&quot;&gt;7&lt;/span&gt;    	&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;字典&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; {
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt;  	&amp;quot;TITLE&amp;quot;: &amp;quot;Template example&amp;quot;,
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt;     &amp;quot;BODY&amp;quot;: &amp;quot;This is a simple template example.\nIt&amp;#39;s boring&amp;quot;,
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt;     &amp;quot;DATE&amp;quot;: &amp;quot;11/20/2005&amp;quot;
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt; }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;经过Ctemplate模板引擎替换成&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; 	&lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; 		&lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;Template example&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt; 	&lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt;    &lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;6&lt;/span&gt;    		This is a simple template example.It&amp;#39;s boring
&lt;span class=&quot;lineno&quot;&gt;7&lt;/span&gt;    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意：变量不要求全都有，可以相互冗余或缺少。比如字典里没有META_TAGS而模板里没DATE。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;代码实现&lt;/h3&gt;
&lt;p&gt;        有了上面抽象的基本原理，我们来看下简单的代码实现:&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;tpl&quot;&gt;首先得建立一个模板文件.tpl&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;example.tpl&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt;    	Hello {{NAME}},
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt;    	You have just won ${{VALUE}}!
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt;    	{{#IN_CA}}Well, ${{TAXED_VALUE}}, after taxes.{{/IN_CA}}
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;cc&quot;&gt;然后建立C/C++程序&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;example.cc&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; #include &lt;span class=&quot;nt&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt; #include &lt;span class=&quot;nt&quot;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt; #include &lt;span class=&quot;nt&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt; /*
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt; 编译完成后添加这个头文件
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt; */
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt; #include &lt;span class=&quot;nt&quot;&gt;&amp;lt;ctemplate&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt; int main(int argc, char** argv) {
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt; 	/*
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt; 	 创建字典，名字叫example
&lt;span class=&quot;lineno&quot;&gt;11&lt;/span&gt; 	*/
&lt;span class=&quot;lineno&quot;&gt;12&lt;/span&gt;    ctemplate::TemplateDictionary dict(&amp;quot;example&amp;quot;);
&lt;span class=&quot;lineno&quot;&gt;13&lt;/span&gt;    
&lt;span class=&quot;lineno&quot;&gt;14&lt;/span&gt;    /*
&lt;span class=&quot;lineno&quot;&gt;15&lt;/span&gt;    	字典是以key-value的形式，这里通过类方法设置
&lt;span class=&quot;lineno&quot;&gt;16&lt;/span&gt;    */
&lt;span class=&quot;lineno&quot;&gt;17&lt;/span&gt;    dict.SetValue(&amp;quot;NAME&amp;quot;, &amp;quot;John Smith&amp;quot;);
&lt;span class=&quot;lineno&quot;&gt;18&lt;/span&gt;       int winnings = rand() % 100000;
&lt;span class=&quot;lineno&quot;&gt;19&lt;/span&gt;       dict.SetIntValue(&amp;quot;VALUE&amp;quot;, winnings);
&lt;span class=&quot;lineno&quot;&gt;20&lt;/span&gt;       dict.SetFormattedValue(&amp;quot;TAXED_VALUE&amp;quot;, &amp;quot;%.2f&amp;quot;, winnings * 0.83);
&lt;span class=&quot;lineno&quot;&gt;21&lt;/span&gt;       // For now, assume everyone lives in CA.
&lt;span class=&quot;lineno&quot;&gt;22&lt;/span&gt;       // (Try running the program with a 0 here instead!)
&lt;span class=&quot;lineno&quot;&gt;23&lt;/span&gt;       if (1) {
&lt;span class=&quot;lineno&quot;&gt;24&lt;/span&gt;         dict.ShowSection(&amp;quot;IN_CA&amp;quot;);
&lt;span class=&quot;lineno&quot;&gt;25&lt;/span&gt;       }
&lt;span class=&quot;lineno&quot;&gt;26&lt;/span&gt;    /*
&lt;span class=&quot;lineno&quot;&gt;27&lt;/span&gt;    	声明一个string变量，将example.tpl写入
&lt;span class=&quot;lineno&quot;&gt;28&lt;/span&gt;    */
&lt;span class=&quot;lineno&quot;&gt;29&lt;/span&gt;       std::string output;
&lt;span class=&quot;lineno&quot;&gt;30&lt;/span&gt;       ctemplate::ExpandTemplate(&amp;quot;example.tpl&amp;quot;, ctemplate::DO_NOT_STRIP, &lt;span class=&quot;err&quot;&gt;&amp;amp;&lt;/span&gt;dict, &lt;span class=&quot;ni&quot;&gt;&amp;amp;output);&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;31&lt;/span&gt;       
&lt;span class=&quot;lineno&quot;&gt;32&lt;/span&gt;     /*
&lt;span class=&quot;lineno&quot;&gt;33&lt;/span&gt;     输出这个页面
&lt;span class=&quot;lineno&quot;&gt;34&lt;/span&gt;     */
&lt;span class=&quot;lineno&quot;&gt;35&lt;/span&gt;       std::cout &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt; output&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;36&lt;/span&gt;       &lt;span class=&quot;na&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;37&lt;/span&gt;    &lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;section-3&quot;&gt;编译链接&lt;/h4&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; gcc -o example example.cc -lctemplate_nothreads
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; /*
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; 	I can use the &amp;quot;nothreads&amp;quot; library because example.cc doesn&amp;#39;t use threads. If example.cc were threaded, I would do something like this instead:
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt; */
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt; gcc -o example example.cc -lctemplate -pthread&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;templates&quot;&gt;模板（Templates）&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;变量&lt;/li&gt;
  &lt;li&gt;开始结束…&lt;/li&gt;
  &lt;li&gt;包含&lt;/li&gt;
  &lt;li&gt;注释&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;字典&lt;/h4&gt;
&lt;p&gt;后台程序负责生成字典
key-value模式，key肯定得是字符串，value可以是变量（variable），章节（section）或者是子模板（template-include）。&lt;/p&gt;


    </content>
  </entry>
  
  <entry>
    <title>高可用聊天室构建实习故事II Nginx+FastCGI配置二</title>
    <link href="/study/%E8%84%9A%E6%9C%AC%E5%92%8C%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8/"/>
    <updated>2015-07-23T00:00:00+08:00</updated>
    <id>/study/脚本和设置开机启动</id>
    <author>
      <name>Carson Lin</name>
      <uri>/</uri>
      <email>carsonxiaoyang@gmail.com</email>
    </author>
    <content type="html">
      
      &lt;h3 id=&quot;section&quot;&gt;前言：&lt;/h3&gt;
&lt;p&gt;    上一章讲述了如何配置Nginx和FastCGI，并运行了一个简单Demo，那么问题来了。如果不想每次重新开机都要在命令行敲那么长命令的话，要怎么办？这个时候我们就得自己动手来写下脚本并设置成开机启动了。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;脚本编写：&lt;/h3&gt;

&lt;h4 id=&quot;section-2&quot;&gt;参考资料：&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://tldp.org/LDP/abs/html/&quot;&gt;http://tldp.org/LDP/abs/html/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://wiki.ubuntu.org.cn/Shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80#Shell.E9.87.8C.E7.9A.84.E5.87.BD.E6.95.B0&quot;&gt;http://wiki.ubuntu.org.cn/Shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80#Shell.E9.87.8C.E7.9A.84.E5.87.BD.E6.95.B0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;nginx&quot;&gt;Nginx启动脚本编写&lt;/h4&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; #!/bin/bash
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt; # nginx Startup script for the Nginx HTTP Server
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt; # it is v.0.0.2 version.
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt; # chkconfig: - 85 15
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt; # description: Nginx is a high-performance web and proxy server.
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt; #              It has a lot of features, but it&amp;#39;s not for everyone.
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt; # processname: nginx
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt; # pidfile: /var/run/nginx.pid
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt; # config: /usr/local/nginx/conf/nginx.conf
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;11&lt;/span&gt; #注意：这里的三个变量需要根据具体的环境而做修改。
&lt;span class=&quot;lineno&quot;&gt;12&lt;/span&gt; nginxd=/usr/local/nginx/sbin/nginx
&lt;span class=&quot;lineno&quot;&gt;13&lt;/span&gt; nginx_config=/usr/local/nginx/conf/nginx.conf
&lt;span class=&quot;lineno&quot;&gt;14&lt;/span&gt; nginx_pid=/usr/local/nginx/logs/nginx.pid
&lt;span class=&quot;lineno&quot;&gt;15&lt;/span&gt; RETVAL=0
&lt;span class=&quot;lineno&quot;&gt;16&lt;/span&gt; prog=&amp;quot;nginx&amp;quot;
&lt;span class=&quot;lineno&quot;&gt;17&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;18&lt;/span&gt; # 如果nginx可执行，则返回真，否则错误退出.
&lt;span class=&quot;lineno&quot;&gt;19&lt;/span&gt; [ -x $nginxd ] || exit 1
&lt;span class=&quot;lineno&quot;&gt;20&lt;/span&gt; # 函数
&lt;span class=&quot;lineno&quot;&gt;21&lt;/span&gt; start() {
&lt;span class=&quot;lineno&quot;&gt;22&lt;/span&gt; if [ -e $nginx_pid ];then  #-e判断文件是否存在，若存在说明nginx已经启动
&lt;span class=&quot;lineno&quot;&gt;23&lt;/span&gt;    echo &amp;quot;nginx already running....&amp;quot;
&lt;span class=&quot;lineno&quot;&gt;24&lt;/span&gt;    exit 1
&lt;span class=&quot;lineno&quot;&gt;25&lt;/span&gt; fi
&lt;span class=&quot;lineno&quot;&gt;26&lt;/span&gt;    echo -n $&amp;quot;Starting $prog: &amp;quot;
&lt;span class=&quot;lineno&quot;&gt;27&lt;/span&gt;    $nginxd -c ${nginx_config}  #-c是为了导入配置文件
&lt;span class=&quot;lineno&quot;&gt;28&lt;/span&gt;    RETVAL=$?
&lt;span class=&quot;lineno&quot;&gt;29&lt;/span&gt;    echo
&lt;span class=&quot;lineno&quot;&gt;30&lt;/span&gt;    [ $RETVAL = 0 ]  
&lt;span class=&quot;lineno&quot;&gt;31&lt;/span&gt;    return $RETVAL
&lt;span class=&quot;lineno&quot;&gt;32&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;33&lt;/span&gt; # Stop nginx daemons functions.
&lt;span class=&quot;lineno&quot;&gt;34&lt;/span&gt; stop() {
&lt;span class=&quot;lineno&quot;&gt;35&lt;/span&gt;   echo -n $&amp;quot;Stopping $prog: &amp;quot;
&lt;span class=&quot;lineno&quot;&gt;36&lt;/span&gt;   $nginxd -s stop
&lt;span class=&quot;lineno&quot;&gt;37&lt;/span&gt;   RETVAL=$?
&lt;span class=&quot;lineno&quot;&gt;38&lt;/span&gt;   echo
&lt;span class=&quot;lineno&quot;&gt;39&lt;/span&gt;   [ $RETVAL = 0 ] &lt;span class=&quot;err&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; rm -f /var/lock/subsys/nginx $nginx_pid
&lt;span class=&quot;lineno&quot;&gt;40&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;41&lt;/span&gt; # reload nginx service functions.
&lt;span class=&quot;lineno&quot;&gt;42&lt;/span&gt; reload() {
&lt;span class=&quot;lineno&quot;&gt;43&lt;/span&gt;   echo -n $&amp;quot;Reloading $prog: &amp;quot;
&lt;span class=&quot;lineno&quot;&gt;44&lt;/span&gt;   kill -HUP `cat ${nginx_pid}`  #平滑重启，会先启动新进程，然后再自动结束旧进程
&lt;span class=&quot;lineno&quot;&gt;45&lt;/span&gt;   RETVAL=$?
&lt;span class=&quot;lineno&quot;&gt;46&lt;/span&gt;   echo
&lt;span class=&quot;lineno&quot;&gt;47&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;48&lt;/span&gt; # See how we were called.
&lt;span class=&quot;lineno&quot;&gt;49&lt;/span&gt; case &amp;quot;$1&amp;quot; in
&lt;span class=&quot;lineno&quot;&gt;50&lt;/span&gt;   start)
&lt;span class=&quot;lineno&quot;&gt;51&lt;/span&gt;           start
&lt;span class=&quot;lineno&quot;&gt;52&lt;/span&gt;           ;;
&lt;span class=&quot;lineno&quot;&gt;53&lt;/span&gt;   stop)
&lt;span class=&quot;lineno&quot;&gt;54&lt;/span&gt;           stop
&lt;span class=&quot;lineno&quot;&gt;55&lt;/span&gt;           ;;
&lt;span class=&quot;lineno&quot;&gt;56&lt;/span&gt;   reload)
&lt;span class=&quot;lineno&quot;&gt;57&lt;/span&gt;           reload
&lt;span class=&quot;lineno&quot;&gt;58&lt;/span&gt;           ;;
&lt;span class=&quot;lineno&quot;&gt;59&lt;/span&gt;   restart)
&lt;span class=&quot;lineno&quot;&gt;60&lt;/span&gt;           stop
&lt;span class=&quot;lineno&quot;&gt;61&lt;/span&gt;           start
&lt;span class=&quot;lineno&quot;&gt;62&lt;/span&gt;           ;;
&lt;span class=&quot;lineno&quot;&gt;63&lt;/span&gt;   status)
&lt;span class=&quot;lineno&quot;&gt;64&lt;/span&gt;           status $prog
&lt;span class=&quot;lineno&quot;&gt;65&lt;/span&gt;           RETVAL=$?
&lt;span class=&quot;lineno&quot;&gt;66&lt;/span&gt;           ;;
&lt;span class=&quot;lineno&quot;&gt;67&lt;/span&gt;   *)
&lt;span class=&quot;lineno&quot;&gt;68&lt;/span&gt;           echo $&amp;quot;Usage: $prog {start|stop|restart|reload|status|help}&amp;quot;
&lt;span class=&quot;lineno&quot;&gt;69&lt;/span&gt;           exit 1
&lt;span class=&quot;lineno&quot;&gt;70&lt;/span&gt; esac
&lt;span class=&quot;lineno&quot;&gt;71&lt;/span&gt; exit $RETVAL&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;spwan-fcgi&quot;&gt;spwan-fcgi脚本编写&lt;/h3&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; #!/bin/bash
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; spawn=/usr/local/nginx/sbin/spawn-fcgi
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt; $spawn -a 127.0.0.1 -p 8088 -f /usr/local/nginx/cgibin/demo
&lt;span class=&quot;lineno&quot;&gt;6&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;7&lt;/span&gt; exit 0;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;section-3&quot;&gt;然后&lt;/h4&gt;
&lt;p&gt;    将脚本放到&lt;code&gt;/etc/init.d&lt;/code&gt;里，将脚本权限设置成可执行&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; sudo chmod a+x /etc/init.d/nginx
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; sudo chmod a+x /etc/init.d/spwan-fcgi&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;    打开&lt;code&gt;/etc/init.d/rc.local&lt;/code&gt;在末尾写入&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; /etc/init.d/nginx start
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; /etc/init.d/spawn-fcgi&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;    重启，看下是否启动&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; ps -ef | grep nginx
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; 或者
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; lsof -i:8080
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt; 或者
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt; netstat -anp | grep 8080
&lt;span class=&quot;lineno&quot;&gt;6&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;7&lt;/span&gt; #ps：这里可能需要sudo&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1 id=&quot;section-4&quot;&gt;最后&lt;/h1&gt;
&lt;p&gt;    这样每次开机就不用重新配置，若有多个CGI程序，需要监听多个端口，只需要在spwan-fcgi脚本里设置就行。&lt;/p&gt;

    </content>
  </entry>
  
  <entry>
    <title>高可用聊天室构建实习故事I Nginx+FastCGI配置一</title>
    <link href="/study/Nginx+FastCGI%E9%85%8D%E7%BD%AE/"/>
    <updated>2015-07-19T00:00:00+08:00</updated>
    <id>/study/Nginx+FastCGI配置</id>
    <author>
      <name>Carson Lin</name>
      <uri>/</uri>
      <email>carsonxiaoyang@gmail.com</email>
    </author>
    <content type="html">
      
      &lt;h3 id=&quot;section&quot;&gt;起因：&lt;/h3&gt;
&lt;p&gt;    最近在某公司实习，Leader给了个2个月的项目考核能力。&lt;code&gt;实现一个webQQ，后台要用CGI并用C语言写，支持2W人同时在线，而且系统要高可用。资源是给了5台服务器&lt;/code&gt;。什么是CGI，如何运用5台服务器构建负载均衡等问题一下子扑面而来，之前虽然写过的网站不少，但都是用PHP并且是现成的框架，什么都封装好的，服务器端如何配置，到底是怎样一个流程完全不知道。只知道客户端发一个http请求到服务器，服务器用PHP处理完业务逻辑之后再发回给客户端。这次是一个沉淀的机会，所以坚持写下这段实习故事，当做总结。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;初步接触：&lt;/h3&gt;
&lt;p&gt;    暂时先抛开2W并发，高可用等要求，第一步我们当然得先实现功能，就是得让网站跑起来。这便引出了第一个问题：&lt;code&gt;什么是CGI编程&lt;/code&gt;？&lt;/p&gt;

&lt;h3 id=&quot;cgi&quot;&gt;CGI是什么？&lt;/h3&gt;
&lt;p&gt;    CGI（common gateway interface），通用网关接口协议。一个网站访问的过程大致是这样的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;客户端（浏览器）发送一个http请求（一般通过TCP）到服务器（Apache,Nginx等）80端口&lt;/li&gt;
  &lt;li&gt;服务器进程接受到http报文后，经过处理（将一些信息写进环境变量）然后调用后台CGI程序，把处理过的信息传入CGI程序，这中间采用标准输入输出，服务器标准输出对应CGI程序的标准输入&lt;/li&gt;
  &lt;li&gt;CGI程序处理完业务逻辑后通过标准输出返回给服务器，服务器再返回给客户端（浏览器）&lt;/li&gt;
  &lt;li&gt;服务器断开连接
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;    这里的CGI输入输出的介质是采用端口监听。
    更详细地步骤如下：
&lt;img src=&quot;/images/2015-07-19-1.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;(1)浏览器通过URL连接到服务器&lt;/li&gt;
  &lt;li&gt;(2)服务器将URL翻译成路径和文件名&lt;/li&gt;
  &lt;li&gt;(3)服务器将URL指向一个应该程序而不是一个静态文件&lt;/li&gt;
  &lt;li&gt;(4)服务器为应用程序执行做准备&lt;/li&gt;
  &lt;li&gt;(5)应用程序执行，读取标准输入和有关环境变量&lt;/li&gt;
  &lt;li&gt;(6)应用程序准备进行标准输出&lt;/li&gt;
  &lt;li&gt;(7)应用程序发送标准输出并结束&lt;/li&gt;
  &lt;li&gt;(8)服务器断开连接&lt;/li&gt;
  &lt;li&gt;(9)浏览器显示应用程序的输出结果&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cgi-1&quot;&gt;为什么要用CGI？&lt;/h3&gt;
&lt;p&gt;    使用CGI可以使后台服务程序和服务器极大解耦。服务器的崩溃并不会影响后台服务（这里的后台服务是指上图服务器之后的层面）。这里可以对比一下Php在Apache的运行模式。可以参考&lt;a href=&quot;http://www.cnblogs.com/phphuaibei/archive/2011/09/13/2174927.html&quot;&gt;php原理&lt;/a&gt;或者其他资料。简单来说，就是Php在Apache上有三种运行模式&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Apache模块DLL&lt;/li&gt;
  &lt;li&gt;CGI&lt;/li&gt;
  &lt;li&gt;FastCGI&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;    第三种后面再详述，第一种是将PHP作为Apache的一个模块来运行，Apache启动的时候会启动多个服务器进程（这又涉及到于Apache的preforker和worker模式），而Php解释引擎也集成在里面。Php作为Apache的一个模块，必须寄生在Apache上财能运行。&lt;br /&gt;
    所以，使用CGI就不同上述模式，它可以把后台服务和Apache解耦。&lt;/p&gt;

&lt;h3 id=&quot;fastcgi&quot;&gt;FastCGI&lt;/h3&gt;
&lt;p&gt;    那么CGI又有什么缺点呢？从上述CGI的运行原理来看，每一条http请求都会有一次CGI程序的调用和退出。将CGI程序加载进内存，释放内存的代价是巨大的，也是十分浪费的。那么有一个很自然的想法，能不能把CGI程序设置成一开始就启动，弄成一个常驻进程，处理多次（注意，是多次同个http请求，不是多个）请求呢？。FastCGI就是这样一种机制。&lt;br /&gt;
&lt;br /&gt;
    先从感性上对比下CGI和FastCGI：
&lt;img src=&quot;/images/2015-07-19-2.jpg&quot; /&gt;
&lt;img src=&quot;/images/2015-07-19-3.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;    从上图可以看出，FastCGI多了一个进程管理器，在服务器启动时，启动进程管理器（Php对应PHP-FPM，C对应spawn-fcgi），进程管理器再去启动多个cgi进程（每个进程监听一个端口）。请求过程跟上面CGI一样，只是多了一层进程管理器转发而且请求返回结果后cgi进程不会退出。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;FastCGI的官方文档
&lt;a href=&quot;http://www.fastcgi.com/drupal/&quot;&gt;FastCGI的官方文档&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;nginxfastcgi&quot;&gt;Nginx+FastCGI&lt;/h3&gt;
&lt;p&gt;    在对CGI和FastCGI有一个基本的认识之后，我们从实例当下看下如何配置Nginx服务器+FastCGI,这里FastCGI用C/C++实现。
&lt;img src=&quot;/images/2015-07-19-4.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图是另外一种表示方法，这里的wraper就是所谓的进程管理器。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;环境部署（部分参考网上资料）&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;nginx的安装、部署与配置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;到nginx官网下载最新版本的nginx&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[安装]

根据README解压并安装
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; ./configure 
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt;     make
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt;     make install （默认安装到/usr/local/nginx）
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt;     [配置和管理]    
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt;     1）执行选项
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt;         -c &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;/path/to/config&amp;gt; 为 Nginx 指定一个配置文件，来代替缺省的。不输入则使用默认的配置文件。
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;11&lt;/span&gt;         -t 不运行，而仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。
&lt;span class=&quot;lineno&quot;&gt;12&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;13&lt;/span&gt;         -v 显示 nginx 的版本。
&lt;span class=&quot;lineno&quot;&gt;14&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;15&lt;/span&gt;         -V 显示 nginx 的版本，编译器版本和配置参数。
&lt;span class=&quot;lineno&quot;&gt;16&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;17&lt;/span&gt;  
&lt;span class=&quot;lineno&quot;&gt;18&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;19&lt;/span&gt;     2）检查配置文件
&lt;span class=&quot;lineno&quot;&gt;20&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;21&lt;/span&gt;         sudo ./nginx -t
&lt;span class=&quot;lineno&quot;&gt;22&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;23&lt;/span&gt;         nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok
&lt;span class=&quot;lineno&quot;&gt;24&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;25&lt;/span&gt;         nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful
&lt;span class=&quot;lineno&quot;&gt;26&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;27&lt;/span&gt;      3）启动 - 默认和特殊
&lt;span class=&quot;lineno&quot;&gt;28&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;29&lt;/span&gt;         /usr/local/nginx/sbin/nginx （默认启动方式）
&lt;span class=&quot;lineno&quot;&gt;30&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;31&lt;/span&gt;         /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf （指定配置文件启动）
&lt;span class=&quot;lineno&quot;&gt;32&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;33&lt;/span&gt;     4）查看nginx进程号（master是主进程）
&lt;span class=&quot;lineno&quot;&gt;34&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;35&lt;/span&gt;         ps -ef | grep nginx
&lt;span class=&quot;lineno&quot;&gt;36&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;37&lt;/span&gt;     5）重新加载配置文件
&lt;span class=&quot;lineno&quot;&gt;38&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;39&lt;/span&gt;         sudo kill -HUP [nginx主进程号]
&lt;span class=&quot;lineno&quot;&gt;40&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;41&lt;/span&gt;         通过系统的信号控制 Nginx
&lt;span class=&quot;lineno&quot;&gt;42&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;43&lt;/span&gt;         可以使用信号系统来控制主进程。默认，nginx 将其主进程的 pid 写入到 /usr/local/nginx/logs/nginx.pid 文件中。通过传递参数        给 ./configure 或使用 pid 指令，来改变该文件的位置。
&lt;span class=&quot;lineno&quot;&gt;44&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;45&lt;/span&gt;        主进程可以处理以下的信号：
&lt;span class=&quot;lineno&quot;&gt;46&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;47&lt;/span&gt;         命令 说明 备注
&lt;span class=&quot;lineno&quot;&gt;48&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;49&lt;/span&gt;         TERM, INT 快速关闭
&lt;span class=&quot;lineno&quot;&gt;50&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;51&lt;/span&gt;         QUIT 从容关闭
&lt;span class=&quot;lineno&quot;&gt;52&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;53&lt;/span&gt;         HUP 重载配置
&lt;span class=&quot;lineno&quot;&gt;54&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;55&lt;/span&gt; 用新的配置开始新的工作进程    从容关闭旧的工作进程
&lt;span class=&quot;lineno&quot;&gt;56&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;57&lt;/span&gt;         USR1 重新打开日志文件
&lt;span class=&quot;lineno&quot;&gt;58&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;59&lt;/span&gt;         USR2 平滑升级可执行程序
&lt;span class=&quot;lineno&quot;&gt;60&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;61&lt;/span&gt;         WINCH 从容关闭工作进程
&lt;span class=&quot;lineno&quot;&gt;62&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;63&lt;/span&gt;     6）默认目录结构
&lt;span class=&quot;lineno&quot;&gt;64&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;65&lt;/span&gt;         主目录：/usr/local/nginx/
&lt;span class=&quot;lineno&quot;&gt;66&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;67&lt;/span&gt;         配置目录：/usr/local/nginx/conf/
&lt;span class=&quot;lineno&quot;&gt;68&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;69&lt;/span&gt;         root目录：/usr/local/nginx/html/
&lt;span class=&quot;lineno&quot;&gt;70&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;71&lt;/span&gt;         可执行文件路径：/usr/local/nginx/sbin/&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;spawn_fastcgi的安装、部署与配置&lt;/p&gt;

    &lt;p&gt;spawn_fastcgi  https://github.com/lighttpd/spawn-fcgi&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; 下载以后解压并安装（请记得看README）
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt;     如果没有configure，请先执行./autogen.sh，生成configure
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt;     ./configure
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt;     make
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt;     编译好以后，将可执行文件移动到nginx的sbin目录下
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;11&lt;/span&gt;     cp ./src/spawn-fcgi /usr/local/nginx/sbin/ （cp到nginx的安装目录下）&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;fastcgi库的安装&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个库主要重载了printf和其他几个函数，是很小的一个库。重载printf用于输出流重定向，因为我们要把输出定向到进程管理器（spwan_fcgi）上&lt;br /&gt;
库地址 http://www.fastcgi.com/dist/fcgi.tar.gz&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; tar –zxvf fcgi.tar.gz
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; ./configure
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; make
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt; make install
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;6&lt;/span&gt; 编译时如出现，fcgio.cpp error &amp;#39;eof&amp;#39; was not declared in this scope
&lt;span class=&quot;lineno&quot;&gt;7&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;8&lt;/span&gt; 在/include/fcgio.h文件中加上 #include &lt;span class=&quot;nt&quot;&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;，然后再编译安装就通过了&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Demo和web发布&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[CGI程序]&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; #include &lt;span class=&quot;nt&quot;&gt;&amp;lt;fcgi_stdio.h&amp;gt;&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt; #include &lt;span class=&quot;nt&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt; int main() { 
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt; int count = 0; 
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt; while (FCGI_Accept() &amp;gt;= 0) { 
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt; printf(&amp;quot;Content-type: text/html\r\n&amp;quot; 
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt; &amp;quot;\r\n&amp;quot; 
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt; &amp;quot;&amp;quot; 
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt; &amp;quot;FastCGI Hello!&amp;quot; 
&lt;span class=&quot;lineno&quot;&gt;11&lt;/span&gt; &amp;quot;Request number %d running on host%s &amp;quot; 
&lt;span class=&quot;lineno&quot;&gt;12&lt;/span&gt; &amp;quot;Process ID: %d\n&amp;quot;, ++count, getenv(&amp;quot;SERVER_NAME&amp;quot;), getpid()); 
&lt;span class=&quot;lineno&quot;&gt;13&lt;/span&gt; } 
&lt;span class=&quot;lineno&quot;&gt;14&lt;/span&gt; return 0; 
&lt;span class=&quot;lineno&quot;&gt;15&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;16&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;17&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;18&lt;/span&gt; [编译]
&lt;span class=&quot;lineno&quot;&gt;19&lt;/span&gt; g++ demo.cc -o demo -lfcgi​&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;直接运行可执行文件，看看能否正常运行。如果出现缺少库libfcgi.so.0，则自己需要手动把/usr/local/lib/libfcgi.so.0库建立一个链接到/usr/lib/目录下：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; ln -s /usr/local/lib/libfcgi.so.0 /usr/lib/（或者把so的库路径添加到/etc/ld.so.conf，并执行ldconfig更新一下）&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Web发布&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;1）将CGI可执行程序移动到nginx的安装目录下 /usr/local/nginx/cgibin （文件夹不存在则自己创建） &lt;/p&gt;

&lt;p&gt;2）启动spawn-fcgi管理进程，并绑定server IP和端口（不要跟nginx的监听端口重合）&lt;/p&gt;

&lt;p&gt;Demo中使用&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; /usr/local/nginx/sbin/spawn-fcgi -a 127.0.0.1 -p 8088 -f /usr/local/nginx/cgibin/demo
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; 查看一下8088端口是否已成功：
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt; netstat -nap | grep 8088
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt; 或者
&lt;span class=&quot;lineno&quot;&gt;6&lt;/span&gt; lsof -i:8080
&lt;span class=&quot;lineno&quot;&gt;7&lt;/span&gt; ​&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3）更改nginx.conf配置文件，让nginx转发请求&lt;/p&gt;

&lt;p&gt;在http节点的子节点-“server节”点中下添加配置&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; location ~ \.cgi$ {
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; 	fastcgi_pass 127.0.0.1:8088; 
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; 	fastcgi_param SCRIPT_FILENAME fcgi$fastcgi_script_name;
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt; 	include fastcgi_params;
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt; }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4）重启nginx或者重新加载配置文件&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; kill -HUP [pid]
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; 或者
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; 重启
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt; killall nginx
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt; ./nginxs&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;5)打开浏览器输入
http://localhost/demo.cgi（这里只要后缀是.cgi就可以）&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;备注：&lt;/h3&gt;
&lt;p&gt;    注意上面代码中的&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; while (FCGI_Accept() &amp;gt;= 0) { 
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; printf(&amp;quot;Content-type: text/html\r\n&amp;quot; 
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; 	&amp;quot;\r\n&amp;quot; 
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt; 	&amp;quot;&amp;quot; 
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt; 	&amp;quot;FastCGI Hello!&amp;quot; 
&lt;span class=&quot;lineno&quot;&gt;6&lt;/span&gt; 	&amp;quot;Request number %d running on host%s &amp;quot; 
&lt;span class=&quot;lineno&quot;&gt;7&lt;/span&gt; 	&amp;quot;Process ID: %d\n&amp;quot;, ++count, getenv(&amp;quot;SERVER_NAME&amp;quot;), getpid()); 
&lt;span class=&quot;lineno&quot;&gt;8&lt;/span&gt; }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里printf最好换成FCGI_printf，不然当引入stdio头文件的时候会发生错误。&lt;br /&gt;
这里 while (FCGI_Accept() &amp;gt;= 0)表示接受到一个新的请求，然后执行逻辑处理，完成后再回到while循环的开始，阻塞等待下一个请求。如果没有这个while,那就成普通的CGI程序了。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;最后&lt;/h3&gt;
&lt;p&gt;    这样一个小的demo就运行起来了。下篇将整理更深入配置环境的知识，方便之后的开发。&lt;/p&gt;


    </content>
  </entry>
  
  <entry>
    <title>Web开发遇到问题总结</title>
    <link href="/study/Web%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <updated>2015-07-13T00:00:00+08:00</updated>
    <id>/study/Web开发遇到问题汇总</id>
    <author>
      <name>Carson Lin</name>
      <uri>/</uri>
      <email>carsonxiaoyang@gmail.com</email>
    </author>
    <content type="html">
      
      &lt;h3 id=&quot;section&quot;&gt;开头&lt;/h3&gt;
&lt;p&gt;    这里主要是WEB开发中遇到的一些小问题的汇总。&lt;/p&gt;

&lt;h3 id=&quot;javascript&quot;&gt;javascript篇&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;1、使用webuploader时选择按钮死活无效，调了半天才发现是js文件重名了，虽然是放在不同文件目录下。修改其中一个的文件名即可解决。

2、使用AJAX的时候会存在一个异步问题，所以若要根据AJAX返回结果进行处理的话，必须放在回调函数里
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;mysql&quot;&gt;MySQL篇&lt;/h3&gt;
&lt;p&gt;http://blog.chinaunix.net/uid-20639775-id-3249105.html&lt;/p&gt;

&lt;p&gt;1、主机连接虚拟机MySQL,权限控制
2、MySQL找不到mysqld.sock
3、MySQL包的组成&lt;/p&gt;

&lt;p&gt;MySQL C API 每一次query如果产生结果集，那么都得调用mysql_free_result释放&lt;/p&gt;

&lt;h3 id=&quot;git&quot;&gt;Git篇&lt;/h3&gt;

&lt;h4 id=&quot;redis&quot;&gt;Redis篇&lt;/h4&gt;
&lt;p&gt;example.c:(.text+0x319): undefined reference to `freeReplyObject’
g++ -lhiredis，需要链接的库都在/usr/local/include,学习了g++链接库&lt;/p&gt;

&lt;p&gt;http://blog.csdn.net/sahusoft/article/details/7388617&lt;/p&gt;

&lt;h3 id=&quot;c&quot;&gt;C++&lt;/h3&gt;
&lt;p&gt;char *强转string的时候不能为空，不然会报错&lt;/p&gt;

    </content>
  </entry>
  
  <entry>
    <title>设计模式学习三</title>
    <link href="/study/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B8%89/"/>
    <updated>2015-07-03T00:00:00+08:00</updated>
    <id>/study/设计模式学习三</id>
    <author>
      <name>Carson Lin</name>
      <uri>/</uri>
      <email>carsonxiaoyang@gmail.com</email>
    </author>
    <content type="html">
      
      &lt;h3 id=&quot;section&quot;&gt;开头&lt;/h3&gt;
&lt;p&gt;    上一章总结了创建型模式的四种，详见&lt;a href=&quot;http://lxyyxl638.github.io/study/设计模式学习二/&quot;&gt;设计模式学习二&lt;/a&gt;。这一章来总结最后一个创建型模式————原型模式(Prototype)。我们还是通过例子来学习。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;例子&lt;/h3&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; //PC
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt; class PC {
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt; 	virtual void addCPU(CPU*) {}//装配CPU
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt; 	virtual void addCard(Card*) {}//装配显卡
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt; //CPU类
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt; class CPU {}
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt; //显卡类
&lt;span class=&quot;lineno&quot;&gt;11&lt;/span&gt; class Card{}
&lt;span class=&quot;lineno&quot;&gt;12&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;13&lt;/span&gt; //Intel工艺的CPU
&lt;span class=&quot;lineno&quot;&gt;14&lt;/span&gt; class IntelCPU : public CPU {
&lt;span class=&quot;lineno&quot;&gt;15&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;16&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;17&lt;/span&gt; //IBM工艺的CPU
&lt;span class=&quot;lineno&quot;&gt;18&lt;/span&gt; class IBMCPU : public CPU {
&lt;span class=&quot;lineno&quot;&gt;19&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;20&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;21&lt;/span&gt; //Intel工艺的显卡
&lt;span class=&quot;lineno&quot;&gt;22&lt;/span&gt; class IntelCard : public Card {
&lt;span class=&quot;lineno&quot;&gt;23&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;24&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;25&lt;/span&gt; //IBM工艺的显卡
&lt;span class=&quot;lineno&quot;&gt;26&lt;/span&gt; class IBMCard : public Card {
&lt;span class=&quot;lineno&quot;&gt;27&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;28&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;29&lt;/span&gt; class factory {
&lt;span class=&quot;lineno&quot;&gt;30&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt;31&lt;/span&gt; 	virtual PC* makePC() {}//返回一台PC
&lt;span class=&quot;lineno&quot;&gt;32&lt;/span&gt; 	virtual CPU* createCPU() {}//生产一个CPU
&lt;span class=&quot;lineno&quot;&gt;33&lt;/span&gt; 	virtual graphics_card* createCard() {}//生产一个显卡
&lt;span class=&quot;lineno&quot;&gt;34&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt;35&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;36&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;37&lt;/span&gt; class PrototypeFactory : public factory{
&lt;span class=&quot;lineno&quot;&gt;38&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt;39&lt;/span&gt; private:
&lt;span class=&quot;lineno&quot;&gt;40&lt;/span&gt; 	CPU* _prototypeCPU;
&lt;span class=&quot;lineno&quot;&gt;41&lt;/span&gt; 	Card* _prototypeCard;
&lt;span class=&quot;lineno&quot;&gt;42&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt;43&lt;/span&gt; public:
&lt;span class=&quot;lineno&quot;&gt;44&lt;/span&gt; 	void PrototypeFactory(CPU* cpu,Card* card) {
&lt;span class=&quot;lineno&quot;&gt;45&lt;/span&gt; 		_prototypeCPU = cpu;//原型
&lt;span class=&quot;lineno&quot;&gt;46&lt;/span&gt; 		_prototypeCard = card;//原型
&lt;span class=&quot;lineno&quot;&gt;47&lt;/span&gt; 	}
&lt;span class=&quot;lineno&quot;&gt;48&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt;49&lt;/span&gt; 	virtual CPU* createCPU() {
&lt;span class=&quot;lineno&quot;&gt;50&lt;/span&gt; 		return _prototypeCPU-&amp;gt;clone();
&lt;span class=&quot;lineno&quot;&gt;51&lt;/span&gt; 	}//生产一个CPU
&lt;span class=&quot;lineno&quot;&gt;52&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt;53&lt;/span&gt; 	virtual graphics_card* createCard() {
&lt;span class=&quot;lineno&quot;&gt;54&lt;/span&gt; 		return _prototypeCard-&amp;gt;clone();
&lt;span class=&quot;lineno&quot;&gt;55&lt;/span&gt; 	}//生产一个显卡
&lt;span class=&quot;lineno&quot;&gt;56&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;57&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;58&lt;/span&gt; //想要自己组装PC的客户
&lt;span class=&quot;lineno&quot;&gt;59&lt;/span&gt; class Client {
&lt;span class=&quot;lineno&quot;&gt;60&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt;61&lt;/span&gt; 	PC* assemblePC(factory* protofactory) {
&lt;span class=&quot;lineno&quot;&gt;62&lt;/span&gt; 		//拿到一个PC实例
&lt;span class=&quot;lineno&quot;&gt;63&lt;/span&gt; 		PC* myPC = protofactory.makePC();
&lt;span class=&quot;lineno&quot;&gt;64&lt;/span&gt; 		CPU* myCPU = protofactory.createCPU();
&lt;span class=&quot;lineno&quot;&gt;65&lt;/span&gt; 		Card* myCard = protofactory.createCard();
&lt;span class=&quot;lineno&quot;&gt;66&lt;/span&gt; 		myPC.addCPU(myPC);
&lt;span class=&quot;lineno&quot;&gt;67&lt;/span&gt; 		myPC.addCard(myCard);
&lt;span class=&quot;lineno&quot;&gt;68&lt;/span&gt; 		return PC
&lt;span class=&quot;lineno&quot;&gt;69&lt;/span&gt; 	}
&lt;span class=&quot;lineno&quot;&gt;70&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt;71&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;72&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;73&lt;/span&gt; int main() {
&lt;span class=&quot;lineno&quot;&gt;74&lt;/span&gt; 	PC* myPC;
&lt;span class=&quot;lineno&quot;&gt;75&lt;/span&gt; 	Client* me = new Client;
&lt;span class=&quot;lineno&quot;&gt;76&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt;77&lt;/span&gt; 	//要一台Intel的CPU,IBM显卡的机器
&lt;span class=&quot;lineno&quot;&gt;78&lt;/span&gt; 	factory* protofactory = new PrototypeFactory(new IntelCPU,new IBMCard);
&lt;span class=&quot;lineno&quot;&gt;79&lt;/span&gt; 	myPC = me.assemblePC(protofactory);
&lt;span class=&quot;lineno&quot;&gt;80&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt;81&lt;/span&gt; 	return 0;
&lt;span class=&quot;lineno&quot;&gt;82&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;83&lt;/span&gt; }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;section-2&quot;&gt;原型模式&lt;/h4&gt;
&lt;p&gt;    原型模式：&lt;code&gt;用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象&lt;/code&gt;。如果我们要配置一台Intel的CPU,IBM的显卡的PC，如果采用抽象工厂的话我们只能再继承abstractory_factory生成一个新类，而使用原型模式，你可以通过构造函数任意搭配。特别是在需要动态加载时候，原型模式的优势就体现出来了。&lt;br /&gt;
    通过将原型传递给PrototypeFactory,它便知道了需要创建对象的种类(什么牌子的CPU，显卡)，然后需要生成对象时便通过原型的拷贝函数返回。当然，拷贝函数必须在IntelCPU类里已经实现。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;与抽象工厂区别&lt;/h4&gt;
&lt;p&gt;    两者之间有可能是竞争关系，但也有可能是合作关系。作为初学者，我只能简单地对比两者。
-	通过上述代码和前面一章的代码，可以看出，原型模式可以获得搭配更灵活的产品（IBM,Intel的部件混合用只需要传入原型不一样就行）。而抽象工厂面对这种情况往往要生成一个新类。
-	原型模式要求部件对象都要实现克隆函数&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;最后&lt;/h4&gt;
&lt;p&gt;    至此5种创建型模式的学习总结就结束了。这仅仅是第一次学习的收获，可能还太浅薄。纸上得来终觉浅，觉知此事要躬行。在以后项目中要有意识地发觉探究里面的设计模式。&lt;/p&gt;


    </content>
  </entry>
  
  <entry>
    <title>设计模式学习二</title>
    <link href="/study/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%BA%8C/"/>
    <updated>2015-06-08T00:00:00+08:00</updated>
    <id>/study/设计模式学习二</id>
    <author>
      <name>Carson Lin</name>
      <uri>/</uri>
      <email>carsonxiaoyang@gmail.com</email>
    </author>
    <content type="html">
      
      &lt;h3 id=&quot;section&quot;&gt;开头&lt;/h3&gt;
&lt;p&gt;    这一章我来总结下对5种创建型设计模式的学习。5种分别是&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;抽象工厂(Abstract Factory)&lt;/li&gt;
  &lt;li&gt;工厂方法(Factory Method)&lt;/li&gt;
  &lt;li&gt;单例模式(Singleton)&lt;/li&gt;
  &lt;li&gt;原型(Prototype)&lt;/li&gt;
  &lt;li&gt;生成器(Builder)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;例子一&lt;/h3&gt;
&lt;p&gt;    定义和概念太难看懂，我们从几个个例子和代码来总结和比较这几种设计模式。&lt;br /&gt;
    我们要组装一台只有CPU和显卡的PC。Intel、IBM都生产CPU、显卡。下面的例子将说明：
-	抽象工厂
-	工厂方法
-	单例模式&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; //PC
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt; class PC {
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt; 	virtual void addCPU(CPU*) {}//装配CPU
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt; 	virtual void addCard(Card*) {}//装配显卡
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt; //CPU类
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt; class CPU {}
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt; //显卡类
&lt;span class=&quot;lineno&quot;&gt;11&lt;/span&gt; class Card{}
&lt;span class=&quot;lineno&quot;&gt;12&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;13&lt;/span&gt; //Intel工艺的CPU
&lt;span class=&quot;lineno&quot;&gt;14&lt;/span&gt; class IntelCPU : public CPU {
&lt;span class=&quot;lineno&quot;&gt;15&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;16&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;17&lt;/span&gt; //IBM工艺的CPU
&lt;span class=&quot;lineno&quot;&gt;18&lt;/span&gt; class IBMCPU : public CPU {
&lt;span class=&quot;lineno&quot;&gt;19&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;20&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;21&lt;/span&gt; //Intel工艺的显卡
&lt;span class=&quot;lineno&quot;&gt;22&lt;/span&gt; class IntelCard : public Card {
&lt;span class=&quot;lineno&quot;&gt;23&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;24&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;25&lt;/span&gt; //IBM工艺的显卡
&lt;span class=&quot;lineno&quot;&gt;26&lt;/span&gt; class IBMCard : public Card {
&lt;span class=&quot;lineno&quot;&gt;27&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;28&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;29&lt;/span&gt; //抽象工厂
&lt;span class=&quot;lineno&quot;&gt;30&lt;/span&gt; class abstract_factory {
&lt;span class=&quot;lineno&quot;&gt;31&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt;32&lt;/span&gt; 	virtual PC* makePC() {}//工厂方法,返回一台PC
&lt;span class=&quot;lineno&quot;&gt;33&lt;/span&gt; 	virtual CPU* createCPU() {}//工厂方法,生产一个CPU
&lt;span class=&quot;lineno&quot;&gt;34&lt;/span&gt; 	virtual graphics_card* createCard() {}//工厂方法,生产一个显卡
&lt;span class=&quot;lineno&quot;&gt;35&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt;36&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;37&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;38&lt;/span&gt; //Intel工厂,不使用单例模式
&lt;span class=&quot;lineno&quot;&gt;39&lt;/span&gt; class Intel : public abstract_factory {
&lt;span class=&quot;lineno&quot;&gt;40&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt;41&lt;/span&gt; 	virtual CPU* createCPU() { return (CPU*) new IntelCPU }//override,生产一个IntelCPU
&lt;span class=&quot;lineno&quot;&gt;42&lt;/span&gt; 	virtual graphics_card* createCard() { return (graphics_card*) new IntelCard}//override,生产一个Intel显卡
&lt;span class=&quot;lineno&quot;&gt;43&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt;44&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;45&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;46&lt;/span&gt; //IBM工厂,使用单例模式
&lt;span class=&quot;lineno&quot;&gt;47&lt;/span&gt; class IBM : public abstract_factory {
&lt;span class=&quot;lineno&quot;&gt;48&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;49&lt;/span&gt; private:
&lt;span class=&quot;lineno&quot;&gt;50&lt;/span&gt; 	static IBM* _instance = 0;//指向实例化对象的指针
&lt;span class=&quot;lineno&quot;&gt;51&lt;/span&gt; protected:
&lt;span class=&quot;lineno&quot;&gt;52&lt;/span&gt; 	IBM(){}//将构造函数设置成protected方法,不能设成private，不然子类就实例化不了了
&lt;span class=&quot;lineno&quot;&gt;53&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt;54&lt;/span&gt; public:
&lt;span class=&quot;lineno&quot;&gt;55&lt;/span&gt; 	//返回一个IBM工厂实例
&lt;span class=&quot;lineno&quot;&gt;56&lt;/span&gt; 	static IBM* getInstance() {
&lt;span class=&quot;lineno&quot;&gt;57&lt;/span&gt; 	  if (0 == _instance) {
&lt;span class=&quot;lineno&quot;&gt;58&lt;/span&gt; 		  _instance = new IBM;
&lt;span class=&quot;lineno&quot;&gt;59&lt;/span&gt; 	  }
&lt;span class=&quot;lineno&quot;&gt;60&lt;/span&gt; 	  return _instance;
&lt;span class=&quot;lineno&quot;&gt;61&lt;/span&gt;    };
&lt;span class=&quot;lineno&quot;&gt;62&lt;/span&gt; 	virtual PC* makePC() {}//返回一台PC
&lt;span class=&quot;lineno&quot;&gt;63&lt;/span&gt; 	virtual CPU* createCPU() { return (CPU*) new IBMCPU }//override,生产一个IBMCPU
&lt;span class=&quot;lineno&quot;&gt;64&lt;/span&gt; 	virtual graphics_card* createCard() { return (graphics_card*) new IBMCard}//override,生产一个IBM显卡
&lt;span class=&quot;lineno&quot;&gt;65&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;66&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;67&lt;/span&gt; //想要自己组装PC的客户
&lt;span class=&quot;lineno&quot;&gt;68&lt;/span&gt; class Client {
&lt;span class=&quot;lineno&quot;&gt;69&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt;70&lt;/span&gt; 	//组装机器，传入一个工厂参数
&lt;span class=&quot;lineno&quot;&gt;71&lt;/span&gt; 	PC* assemblePC(abstract_factory* factory) {
&lt;span class=&quot;lineno&quot;&gt;72&lt;/span&gt; 		//拿到一个PC实例
&lt;span class=&quot;lineno&quot;&gt;73&lt;/span&gt; 		PC* myPC = factory.makePC();
&lt;span class=&quot;lineno&quot;&gt;74&lt;/span&gt; 		CPU* myCPU = factory.createCPU();
&lt;span class=&quot;lineno&quot;&gt;75&lt;/span&gt; 		Card* myCard = factory.createCard();
&lt;span class=&quot;lineno&quot;&gt;76&lt;/span&gt; 		myPC.addCPU(myPC);
&lt;span class=&quot;lineno&quot;&gt;77&lt;/span&gt; 		myPC.addCard(myCard);
&lt;span class=&quot;lineno&quot;&gt;78&lt;/span&gt; 		return PC
&lt;span class=&quot;lineno&quot;&gt;79&lt;/span&gt; 	}
&lt;span class=&quot;lineno&quot;&gt;80&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt;81&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;82&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;83&lt;/span&gt; int main() {
&lt;span class=&quot;lineno&quot;&gt;84&lt;/span&gt; 	Client* me = new Client;
&lt;span class=&quot;lineno&quot;&gt;85&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt;86&lt;/span&gt; 	//没有单例模式的工厂
&lt;span class=&quot;lineno&quot;&gt;87&lt;/span&gt; 	abstract_factory* intel = new Intel;
&lt;span class=&quot;lineno&quot;&gt;88&lt;/span&gt; 	//获得一台intel配置的PC
&lt;span class=&quot;lineno&quot;&gt;89&lt;/span&gt; 	PC* myPC = me.assemblePC(intel);
&lt;span class=&quot;lineno&quot;&gt;90&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt;91&lt;/span&gt; 	或者
&lt;span class=&quot;lineno&quot;&gt;92&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt;93&lt;/span&gt; 	//有单例模式的工厂,不能直接new
&lt;span class=&quot;lineno&quot;&gt;94&lt;/span&gt; 	abstract_factory* IBM = IBM::getInstance();
&lt;span class=&quot;lineno&quot;&gt;95&lt;/span&gt; 	//获得一台IBM配置的PC
&lt;span class=&quot;lineno&quot;&gt;96&lt;/span&gt; 	PC* myPC = me.assemblePC(IBM);
&lt;span class=&quot;lineno&quot;&gt;97&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt;98&lt;/span&gt; 	return 0;
&lt;span class=&quot;lineno&quot;&gt;99&lt;/span&gt; }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;section-2&quot;&gt;抽象工厂：&lt;/h4&gt;
&lt;p&gt;    上面的abstract_factory就是抽象工厂，&lt;code&gt;它提供了一系列相关或者相互依赖的接口，而不用指定他们具体的类&lt;/code&gt;。上面代码中用户只需要往assemblePC传入不同的abstract_factory子类就能得到配置不同的电脑,因为它们的接口都是一样的（createCPU和createCard），抽象工厂生产一个系统的各个部件。所以，抽象工厂一般适用于以下场景：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个系统要由多个产品系列中的一个来配置时（我的PC要么用Intel配置，要么用IBM配置）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;    简而言之，抽象工厂就是在多种系列产品加工厂上再抽象出的一个工厂，方便实现为用户配置提供统一接口。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;工厂方法&lt;/h4&gt;
&lt;p&gt;    上面abstract_factory中的方法（32、33、34行）便是工厂方法，&lt;code&gt;定义一个用于创建对象的接口，让子类决定实例化哪一个类。它使一个类的实例化延迟到子类。&lt;/code&gt;createCPU()创建一个CPU对象，但是Intel还是IBM呢？它只能延迟到它的子类(Intel工厂或者IBM工厂)来实现了，但接口都是一样的。这个还是挺好理解的。&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;单例模式&lt;/h4&gt;
&lt;p&gt;    上面IBM工厂(47行)采用了单例模式，&lt;code&gt;它保证了整个系统中只有一个IBM工厂实例&lt;/code&gt;，直接看代码应该可以明白是如何实现的。这与实际情况也相符合，如果工厂需要统计它生产了多少CPU，那就得用单例模式了。不然用户随便new出很多个Intel工厂的话统计就乱套了。&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;例子二&lt;/h4&gt;
&lt;p&gt;    接下来的例子讲述容易和抽象工厂混淆的生成器模式(Builder),同样针对上面的场景。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;  1&lt;/span&gt; //PC
&lt;span class=&quot;lineno&quot;&gt;  2&lt;/span&gt; class PC {
&lt;span class=&quot;lineno&quot;&gt;  3&lt;/span&gt; 	virtual void addCPU(CPU*) {}//装配CPU
&lt;span class=&quot;lineno&quot;&gt;  4&lt;/span&gt; 	virtual void addCard(Card*) {}//装配显卡
&lt;span class=&quot;lineno&quot;&gt;  5&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;  6&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;  7&lt;/span&gt; //CPU类
&lt;span class=&quot;lineno&quot;&gt;  8&lt;/span&gt; class CPU {}
&lt;span class=&quot;lineno&quot;&gt;  9&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 10&lt;/span&gt; //显卡类
&lt;span class=&quot;lineno&quot;&gt; 11&lt;/span&gt; class Card{}
&lt;span class=&quot;lineno&quot;&gt; 12&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 13&lt;/span&gt; //Intel工艺的CPU
&lt;span class=&quot;lineno&quot;&gt; 14&lt;/span&gt; class IntelCPU : public CPU {
&lt;span class=&quot;lineno&quot;&gt; 15&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt; 16&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 17&lt;/span&gt; //IBM工艺的CPU
&lt;span class=&quot;lineno&quot;&gt; 18&lt;/span&gt; class IBMCPU : public CPU {
&lt;span class=&quot;lineno&quot;&gt; 19&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt; 20&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 21&lt;/span&gt; //Intel工艺的显卡
&lt;span class=&quot;lineno&quot;&gt; 22&lt;/span&gt; class IntelCard : public Card {
&lt;span class=&quot;lineno&quot;&gt; 23&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt; 24&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 25&lt;/span&gt; //IBM工艺的显卡
&lt;span class=&quot;lineno&quot;&gt; 26&lt;/span&gt; class IBMCard : public Card {
&lt;span class=&quot;lineno&quot;&gt; 27&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt; 28&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 29&lt;/span&gt; //生成器，负责生产、组成并返回PC
&lt;span class=&quot;lineno&quot;&gt; 30&lt;/span&gt; class Builder {
&lt;span class=&quot;lineno&quot;&gt; 31&lt;/span&gt; 	//返回一台PC，特别注意这个方法，后文会讲到
&lt;span class=&quot;lineno&quot;&gt; 32&lt;/span&gt; 	virtual PC* getPC() {return 0};
&lt;span class=&quot;lineno&quot;&gt; 33&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt; 34&lt;/span&gt; 	virtual void buildCPU(){}//制作CPU
&lt;span class=&quot;lineno&quot;&gt; 35&lt;/span&gt; 	virtual void buildCard(){}//制作显卡
&lt;span class=&quot;lineno&quot;&gt; 36&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt; 37&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 38&lt;/span&gt; //Intel生成器
&lt;span class=&quot;lineno&quot;&gt; 39&lt;/span&gt; class Intel : public Builder {
&lt;span class=&quot;lineno&quot;&gt; 40&lt;/span&gt; private:
&lt;span class=&quot;lineno&quot;&gt; 41&lt;/span&gt; 	PC* pc;
&lt;span class=&quot;lineno&quot;&gt; 42&lt;/span&gt; 	void assembleCPU(CPU*) {}//组装CPU
&lt;span class=&quot;lineno&quot;&gt; 43&lt;/span&gt; public:
&lt;span class=&quot;lineno&quot;&gt; 44&lt;/span&gt; 	virtual void buildCPU(){
&lt;span class=&quot;lineno&quot;&gt; 45&lt;/span&gt; 		CPU* cpu = createCPU()//伪代码，表示生产了一个CPU，它可以跟上面的抽象工厂一起使用，但这个先忽略
&lt;span class=&quot;lineno&quot;&gt; 46&lt;/span&gt; 		assembleCPU(cpu);//组装CPU
&lt;span class=&quot;lineno&quot;&gt; 47&lt;/span&gt; 	}//制作CPU并组装
&lt;span class=&quot;lineno&quot;&gt; 48&lt;/span&gt; 	virtual void buildCard(){}//制作显卡
&lt;span class=&quot;lineno&quot;&gt; 49&lt;/span&gt; 	//返回一个PC
&lt;span class=&quot;lineno&quot;&gt; 50&lt;/span&gt; 	virtual PC* getPC() {return pc};
&lt;span class=&quot;lineno&quot;&gt; 51&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt; 52&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 53&lt;/span&gt; //想要自己组装PC的客户A
&lt;span class=&quot;lineno&quot;&gt; 54&lt;/span&gt; class ClientA {
&lt;span class=&quot;lineno&quot;&gt; 55&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt; 56&lt;/span&gt; 	//组装机器，传入一个生成器参数
&lt;span class=&quot;lineno&quot;&gt; 57&lt;/span&gt; 	PC* assemblePC(Builder* builder) {
&lt;span class=&quot;lineno&quot;&gt; 58&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt; 59&lt;/span&gt; 		//只装一个CPU
&lt;span class=&quot;lineno&quot;&gt; 60&lt;/span&gt; 		builder.buildCPU();
&lt;span class=&quot;lineno&quot;&gt; 61&lt;/span&gt; 		
&lt;span class=&quot;lineno&quot;&gt; 62&lt;/span&gt; 		//装一个显卡
&lt;span class=&quot;lineno&quot;&gt; 63&lt;/span&gt; 		builder.buildCard();
&lt;span class=&quot;lineno&quot;&gt; 64&lt;/span&gt; 		
&lt;span class=&quot;lineno&quot;&gt; 65&lt;/span&gt; 		//获得PC
&lt;span class=&quot;lineno&quot;&gt; 66&lt;/span&gt; 		return builder.getPC();
&lt;span class=&quot;lineno&quot;&gt; 67&lt;/span&gt; 	}
&lt;span class=&quot;lineno&quot;&gt; 68&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt; 69&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt; 70&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 71&lt;/span&gt; //想要自己组装PC的客户B
&lt;span class=&quot;lineno&quot;&gt; 72&lt;/span&gt; class ClientB {
&lt;span class=&quot;lineno&quot;&gt; 73&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt; 74&lt;/span&gt; 	//组装机器，传入一个生成器参数
&lt;span class=&quot;lineno&quot;&gt; 75&lt;/span&gt; 	PC* assemblePC(Builder* builder) {
&lt;span class=&quot;lineno&quot;&gt; 76&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt; 77&lt;/span&gt; 		//一口气装了3个CPU
&lt;span class=&quot;lineno&quot;&gt; 78&lt;/span&gt; 		builder.buildCPU();
&lt;span class=&quot;lineno&quot;&gt; 79&lt;/span&gt; 		builder.buildCPU();
&lt;span class=&quot;lineno&quot;&gt; 80&lt;/span&gt; 		builder.buildCPU();
&lt;span class=&quot;lineno&quot;&gt; 81&lt;/span&gt; 		
&lt;span class=&quot;lineno&quot;&gt; 82&lt;/span&gt; 		//装一个显卡
&lt;span class=&quot;lineno&quot;&gt; 83&lt;/span&gt; 		builder.buildCard();
&lt;span class=&quot;lineno&quot;&gt; 84&lt;/span&gt; 		
&lt;span class=&quot;lineno&quot;&gt; 85&lt;/span&gt; 		//获得PC
&lt;span class=&quot;lineno&quot;&gt; 86&lt;/span&gt; 		return builder.getPC();
&lt;span class=&quot;lineno&quot;&gt; 87&lt;/span&gt; 	}
&lt;span class=&quot;lineno&quot;&gt; 88&lt;/span&gt; 	...
&lt;span class=&quot;lineno&quot;&gt; 89&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt; 90&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 91&lt;/span&gt; //用户开始使用
&lt;span class=&quot;lineno&quot;&gt; 92&lt;/span&gt; int main() {
&lt;span class=&quot;lineno&quot;&gt; 93&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 94&lt;/span&gt; 	PC* myPC;
&lt;span class=&quot;lineno&quot;&gt; 95&lt;/span&gt; 	Builder* IntelBuilder = new Intel;
&lt;span class=&quot;lineno&quot;&gt; 96&lt;/span&gt; 	ClientA* me = new ClientA
&lt;span class=&quot;lineno&quot;&gt; 97&lt;/span&gt; 	PC = me.assemblePC(IntelBuilder);
&lt;span class=&quot;lineno&quot;&gt; 98&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt; 99&lt;/span&gt; 	return 0;
&lt;span class=&quot;lineno&quot;&gt;100&lt;/span&gt; }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;section-6&quot;&gt;生成器模式&lt;/h4&gt;
&lt;p&gt;    生成器模式定义：&lt;code&gt;将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示&lt;/code&gt;。上面代码乍一看跟抽象工厂差不多，只是把factory换成了builder。但其实本质是不一样的。在生成器模式下有三种角色:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Product(PC)：需要构造的复杂对象&lt;/li&gt;
  &lt;li&gt;Builder(生产和实现装配的Intel,IBM)：为创建Product各个部件指定抽象接口。&lt;/li&gt;
  &lt;li&gt;Director(Client,负责控制装机流程的)：构造一个使用Builder接口的对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;    跟抽象工厂对比：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ClientA和ClientB是看不到CPU,Card这两个部件的。它只能调用builder去装机，但装的具体细节全由builder（Intel）控制，用户(Director)完全不知道，director只能控制装机流程（要装几个CPU，几个显卡）。&lt;/li&gt;
  &lt;li&gt;抽象工厂一开始就获得了构建对象(PC)，而生成器模式是一步一步装载PC，最后才返回给用户PC。这个从时间点上不一样。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;    再回过头去看生成器的定义，构建(CPU的生产和装载具体做法全都封装在了Builder里)和表示(Director通过不同的实现制造出不同的Product)分离。同样的构建过程(同一个builder)可以创建不同表示(3个CPU的PC还是1个CPU的PC)。&lt;/p&gt;

&lt;h4 id=&quot;section-7&quot;&gt;生成器模式和抽象工厂的对比&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;两者都能构建复杂对象。但抽象工厂着重于构建相同系列的部件供给用户使用，用户爱怎么倒腾不关它的事（有用户喜欢把CPU插在内存插槽上或者其他奇奇怪怪的操作），而生成器着重于构建一个产品，它将产品具体装配封装起来，用户只能控制装载流程，但不能控制具体操作(你不能把CPU插在内存上，你只能决定需要几个CPU)。&lt;/li&gt;
  &lt;li&gt;根据上一条和代码，可以看出，抽象工厂是立马将产品生成，而生成器是到最后一步才把产品生成。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-8&quot;&gt;最后&lt;/h4&gt;
&lt;p&gt;撑不住，睡觉了…原型模式下次再总结…&lt;/p&gt;

    </content>
  </entry>
  
  <entry>
    <title>设计模式学习一</title>
    <link href="/study/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B8%80/"/>
    <updated>2015-06-01T00:00:00+08:00</updated>
    <id>/study/设计模式学习一</id>
    <author>
      <name>Carson Lin</name>
      <uri>/</uri>
      <email>carsonxiaoyang@gmail.com</email>
    </author>
    <content type="html">
      
      &lt;p&gt;    最近实习面试几乎场场都会问到设计模式，之前虽然也有用到过，但没有系统地学习过，借此机会补下课。本文仅是基于一个初学小白理解的总结，可能有些漏洞，欢迎纠错。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section&quot;&gt;设计模式分类：&lt;/h3&gt;
&lt;p&gt;常见设计模式有23种，分别为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;创建型：5种&lt;/li&gt;
  &lt;li&gt;结构型：7种&lt;/li&gt;
  &lt;li&gt;行为型：11种&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;创建型模式&lt;/h3&gt;

&lt;p&gt;    创建型模式，按照《设计模式》一书中的说明:&lt;br /&gt;&lt;/p&gt;
&lt;pre&gt;
	&lt;code&gt;
	创建型模式抽象了实例化过程，他们帮助一个系统独立于如何创建、组合和表示它的那些对象。
	一个类创建型模式使用继承改变被实例化的类，而一个对象创建型模式将实例化委托给另一个对象。
	&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;    一开始看这段话的时候没怎么懂，通过形象的例子之后才明白。这里引用书上的例子。你玩一个走迷宫游戏，这里的迷宫游戏就是上面所说的&lt;code&gt;系统&lt;/code&gt;，你可以用createMaze()函数配置这个游戏的场景（实现创建墙壁，门，出入口等操作），有&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;普通迷宫&lt;/li&gt;
  &lt;li&gt;魔法型迷宫（墙壁有魔法效果）&lt;/li&gt;
  &lt;li&gt;HelloKitty主题迷宫&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;    最直接的做法就是在createMaze()里硬编码，这样每次要更换场景的时候就不得不重新更改代码。如果我们能在上面三个迷宫类型上面再抽象出一个类Abstract Maze,就能通过多态将代表三个迷宫场景的子类通过Abstract Maze传递给createMaze()。这样根本不需要改变createMaze()的代码就能实现三种模式的转换。这个就是创建型模式，抽象了实例化过程（迷宫场景的生成），系统独立于对象的创建，组合（创建迷宫的使用者不需要知道对象的具体实现，它只需要接收一个抽象类参数并调用接口就行了），在后文会说明这Abstract Maze其实就是抽象工厂，而createMaze()就是工厂方法。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;结构性模式&lt;/h3&gt;
&lt;p&gt;    顾名思义，结构性模式就是负责组合类和对象，目的是获得更大的结构。结构性类模式采用继承机制来组合接口和实现。根据《设计模式》一书中所说，最简单的例子就是采用多重继承使得子类获得所有父类的性质。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;行为模式&lt;/h3&gt;
&lt;p&gt;    行为模式涉及到算法和对象间职责的分配。行为模式不仅描述对象或类的模式，还描述他们之间的通信模式。这些模式刻划了在运行时难以跟踪的控制流。他们将你的注意力从控制流转移到对象间的联系方式上。—《设计模式》&lt;br /&gt;
    行为类模式采用类继承机制实现在类间分配任务，行为对象通过对象复合以实现更高级的行为。一言以蔽之，行为模式是为了实现更复杂的算法或行为。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;最后&lt;/h3&gt;
&lt;p&gt;    本文仅仅是对三大类设计模式进行了一次梗概，具体每种设计模式是什么样的将在后续的学习中一一阐述。&lt;/p&gt;

    </content>
  </entry>
  
  <entry>
    <title>依图面试总结</title>
    <link href="/study/%E4%BE%9D%E5%9B%BE%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <updated>2015-05-27T00:00:00+08:00</updated>
    <id>/study/依图面试总结</id>
    <author>
      <name>Carson Lin</name>
      <uri>/</uri>
      <email>carsonxiaoyang@gmail.com</email>
    </author>
    <content type="html">
      
      &lt;h3 id=&quot;section&quot;&gt;一面：&lt;/h3&gt;
&lt;p&gt;    1、LeetCode原题，判断一个数是不是2的幂。&lt;br /&gt;
    当时没想起来是LeetCode原题，直观地利用二进制表示是否只有一个1的做法，因为如果是2的幂的话二进制表示肯定只有一个1，这样做法是O(32)的。后来面试官问有什么可以优化的，我没直接想出来，但给出了思考方向。先是试探性地问面试官他现在是希望我想出一个一步到位的算法，得到肯定回答后可以排除一些奇怪的想法，那么只剩下两种可能性。一种是一步算出有多少个1，另一种是消掉其中一个1然后看是否还有1。显然第一种是走不通的，那么只省下第二种可能性，面试官表示了赞同。在经过这样一番沟通后，面试官提示我可以考虑下和x-1的关系，这个时候我才想起这事leetCode原题，但时间太久还是没想起来，现场试验后发现这就是消掉最右边一个1的做法。&lt;br /&gt;
    2、下围棋的情况判断&lt;br /&gt;
    面试官拿了一张纸画了一个围棋盘，然后用黑白磁铁当做棋子摆出个棋局。是围棋规则，要让对手没一口活棋（就是他落哪都不能围住我但自己会被围）。然后又画了一个空格，两个空格，三个空格，四个空格及其以上的情况，其实问题的关键是黑棋只要能构建出两个独立的联通分量的话他就能活（不被围死）。但当时对规则理解实在没咋懂，加上中午没睡觉所以有点懵，没找出关键。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;二面：&lt;/h3&gt;
&lt;p&gt;    1、给一个三维坐标A，找另一个高低位相同的三维坐标，使得离A最近。&lt;br /&gt;
    根据距离公式可以得出三个分量独立，然后每个分量只需要16次枚举就行。当时没想到按最直接的想法想就行，想偏了。在提示下才做出来的。接下来是写代码，这题涉及到字符串和整型的互相转化，写了四个函数。写得比较慢，但好险没出bug，弥补了前面的失误。&lt;br /&gt;
    2、LeetCode原题，给一个字符串，找出最长子串使得其实没一个字符重复&lt;br /&gt;
    LeetCode原题，直接用个数组标记就行，但实在很困，语言表达得很渣。这题没写代码。&lt;br /&gt;
    3、给一个整型数组，找出能整除p的子数组的个数。&lt;br /&gt;
    一开始想复杂了，甚至往动态规划上想去了，其实也是从最直接的做法优化。O（N^2）枚举所有情况，用前缀和(sum[j] - sum[i]) mod p判断，代入问题转换成将前缀和mod p之后看有多少对相同的。这个用个统排计算一下即可，当时漏了一种情况就是sum[i] mod p == 0时要单独加上（长度为1的也符合条件）。这个代码也比较好实现。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;    被突然问了数分成绩，可能是因为第三题看出了这个数学基础不扎实… &lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-3&quot;&gt;三面:&lt;/h3&gt;
&lt;p&gt;    1、写最短路&lt;br /&gt;
    写了个最好写的floyed..&lt;br /&gt;
    2、证明最短路
    写了之后发现自己把自己坑了，竟然要求证明…实在不知道从何下手，在面试官提醒下才加了一维F[i][j][k]用动态规划的方法写出了转移方程。最后问了一个为什么第三维可以省略，这个实在不知道怎么表达，最后他跟我说只需要答在第k次计算时f[i][j]的值还是表示k-1，即没有被更新过即可。&lt;br /&gt;
    3、LeetCode原题，ZigZag打印&lt;br /&gt;
    LeetCode原题，方阵打印。先枚举对角线x + y的和，在逐个遍历即可。当时脑子不清醒用了m,n两个变量变成不是方阵了。&lt;br /&gt;
    4、介绍项目&lt;br /&gt;
    就简单地介绍了下传承，还是被问到了老问题，遇到的最大困难是什么。我答了一是项目协同工作以及我们怎么克服，二是资料审查，当前只能人工，后期打算通过用户筛选。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;    被面试官问了句“数学是不是没学好”…竟然被发现了…&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-5&quot;&gt;四面：&lt;/h3&gt;
&lt;p&gt;    1、两个排好序的数组，求交集&lt;br /&gt;
    用两个光标分别扫描A,B数组，如果A[i] == B[j]，那么就是目标交集，i++,j++。否则，加那个比较小的。这样是O(N)的&lt;br /&gt;
    2、如果一个数组很大，有100w，另外一个很小,只有10&lt;br /&gt;
    扫描小的，然后二分大的，这样是O(nLogM)&lt;br /&gt;
    3、考虑一个1T的文本数据存储，硬盘7200转，I/O 100MB/s，内存16GB，带宽10GB。输入一个数，判断是否存在于文本中。问1s可以满足多少次访问&lt;br /&gt;
    给跪了，磁盘访问这个完全不会，现场教的，要用B+树思想，其实就是建立索引，16GB的索引，然后再读入索引对应的序列。在这样之上读入对应序列的时间几乎可以忽略不计，即没有用到100MB/s那么大的I/O，因此可以减少索引大小，让我算减少多少。我就列方程解，不知道为什么死活解不出来…可能饿得困得头昏眼花了…最后好险面试官放过我了。说我这种算法是学生思维，真正在工程里这是最简单的问题，你需要知道这个东西真正的瓶颈在哪里。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;    边吃饭边面的，脑子已经混了。加上身边很吵，根本不知道自己在想什么，感觉完全跪了。但可能是因为基础的算法想得比较快，而且主动拿出纸笔写代码。（想不出不敢吃饭呀….）最后还是让过了。&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;总结：&lt;/h2&gt;
&lt;p&gt;    总的来说这次没有什么压力，所以面得比较轻松，但是一轮轮车轮战体力脑子实在是个问题。最后都感觉眼前一片模糊了，不过好险坚持了下来。这或许有压力测试的成分吧，所以坚决不放弃还是很有用的。&lt;/p&gt;

    </content>
  </entry>
  
  
</feed>